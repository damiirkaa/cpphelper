{
	"id": "functions",
	"name": "<b>Functions</b>",
	"overview": "This section explains concepts that are critical to understanding <b> functions</b>.",

	"definition": {
		"name": "Определение",
		"page_1": [
			"<b>Function definition</b> \nThe function defines the actions that the program performs. Functions allow you to highlight a set of instructions and give it a name. And then call it multiple times using the assigned name in different parts of the program. A function is essentially a named block of code.",
			"The formal definition of the function looks like this:\n<code>type function_name(parameters) \n{ \ninstructions \n}</code> \nThe first line represents the title of the function. The return type of the function is indicated first. If the function does not return any value, then the type is used<b>void</b>.",
			"Then comes the function name, which represents an arbitrary identifier. The same rules apply to function naming as to variable naming. \nThe parameters are listed in parentheses after the function name. The function may have no parameters, in this case empty brackets are indicated.",
			"After the function header, in curly braces, there is the function body, which contains the instructions to be executed. \nTo return a result, the function uses the operator<b>return</b>. If a function has any type other than void as a return type, then it must necessarily return some value using the return statement.",
			"For example, the definition of the main function, which should be in any C ++ program and from which its execution starts: \n <code> int main () \n {\nreturn 0; \n} </code> \nThe return type of the function is the type<b>int</b>, so the function must use the operator<b>return</b> and return any value that is of type int. The return value is placed after the operator return.",
			"But if the function is of type <b>void</b>, then she does not need to return anything. For example, we could define the following function: \n<code>void hello() \n{ \nstd::cout &lt;&lt; 'hello\n'; \n}</code>",
			"<b>Function execution</b> \nTo execute a function, it must be called. The function is called in the form: \n<code>function_name(parameters);</code> \nThe function name is followed by parentheses in which the arguments are listed - the values for the function parameters.",
			"For example, let's define and execute the simplest function: \n<code>#include &lt;iostream&gt; \nvoid hello() \n{ \nstd::cout &lt;&lt; 'hello\n'; \n} \nint main() \n{ \nhello(); \nhello(); \nreturn 0; \n}</code>",
			"In this case, before calling the function, you must additionally declare it. A function declaration is also called a prototype. The formal declaration looks like this:\n<code>тип function_name(parameters);</code> \nIn fact, this is a function header. That is, for the hello function, the declaration will look like this:",
			"<code>void hello();</code> \nWe use the function declaration: \n<code>#include &lt;iostream&gt; \nvoid hello(); \nint main() \n{ \nhello(); \nhello(); \nreturn 0; \n} \nvoid hello() \n{ \nstd::cout &lt;&lt; 'hello\n'; \n}</code>",
			"In this case, despite the fact that the definition of the function comes after its call, but since the function is already declared before it is called, the compiler will already know about the hello function, and there will be no problems in the program's operation."
		]
	},

	"function_parameters": {
		"name": "Function parameters",
		"page_1": [
			"Different values can be passed to the function through parameters. Parameters listed in parentheses after the function name have the following definition:\n<code>type parameter_name</code> \nFor example, let's define the program of the exchange office:",
			"<code>#include &lt;iostream&gt; \nvoid exchange(double, double); \nint main() \n{ \ndouble rate = 58; \ndouble sum = 5000; \nexchange(rate, sum); \nexchange(60, 5000); \nreturn 0; \n} \nvoid exchange(double currate, double sum) \n{ \ndouble result = sum / currate; \nstd::cout &lt;&lt;  'Rate: ' &lt;&lt; currate &lt;&lt; '\tSum: ' &lt;&lt; sum &lt;&lt; '\tResult: ' &lt;&lt; result &lt;&lt; std::endl; \n}</code>",
			"When we run the program, we get the following console output: \n<b>Rate: 58 \nSum: 5000 \nResult: 86.2069 \nRate: 60 \nSum: 5000 \nResult: 83.3333</b> \nThe exchange function takes two parameters of type double, which are called currate (the current rate) and sum (the amount to be exchanged).",
			"When calling the exchange function, values must be passed for these parameters. The values passed to the parameters of a function when it is called are called arguments. In this case, ordinary numbers are passed as arguments. In this case, arguments are passed by position, that is, the first argument is passed to the first parameter, the second argument is passed to the second parameter, and so on. In this case, the arguments must correspond to the parameters by type or allow implicit conversion to the type of the parameter.",
			"Let's look at another example with functions: \n<code>#include &lt;iostream&gt; \n#include &lt;string&gt; \nvoid square(int); \nvoid display(std::string, int); \nint main() \n{  \ndisplay('Tom', 33); \nsquare(4.56); \nreturn 0; \n} \nvoid square(int x) \n{ \nstd::cout &lt;&lt; 'Square of ' &lt;&lt; x &lt;&lt; ' is equal to ' &lt;&lt; x * x &lt;&Lt; std::endl; \n} \nvoid display(std::string name, int age) \n{ \nstd::cout &Lt;&lt; 'Name: ' &lt;&lt; name &lt;&lt; '\tAge: ' &Lt;&Lt; age &Lt;&Lt; std::endl; \n}</code>",
			"The display function takes parameters of types string and int. When this function is called, the string ('Tom') is passed to it first, since the parameter of the string type comes first, and then the number (33), since the parameter of the int type is the second: display ('Tom', 33)",
			"The square function takes a number and prints its square to the console. The function parameter represents the int type, but when it is called, a floating point number is passed to it, that is, a double value. Therefore, a conversion is made from the double type to the int type, the fractional part is discarded, and as a result, the function receives the number 4."
		],

		"page_2": [
			"<b>Default arguments</b> \nA function can accept default arguments, that is, some values that the function uses if no value is explicitly passed for parameters when called:",
			"<code>#include &lt;iostream&gt; \nvoid multiply(int n, int m = 3) \n{ \nint result = n * m; \nstd::cout &lt;&lt; 'n * m = ' &lt;&lt; result &lt;&lt; std::endl; \n} \nint main() \n{ \nmultiply(4, 5); \nmultiply(4); \nreturn 0; \n}</code>",
			"To set the default value, the parameter is assigned this value int m = 3. And if no value is passed for the second parameter, it will use the default value. Console output of the program: \n <b> n * m = 20 \nn * m = 12",
			"When a prototype of such a function is declared, it can also contain a default value for the parameter. And in this case, we can not define a default value for the parameter in the function - it will be taken from the prototype: \n <code> #include & lt; iostream & gt; \nvoid multiply (int n, int m = 3); \nint main () \n {\nmultiply (4, 5); \nmultiply (4); \nreturn 0; \n} \nvoid multiply (int n, int m) \n {\nint result = n * m; \nstd :: cout & lt; & lt; 'n * m =' & lt; & lt; result & lt; & lt; std :: endl; \n} </ code>"
		]
	}

}
