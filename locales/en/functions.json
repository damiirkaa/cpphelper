{
	"id": "functions",
	"name": "<b>Функции</b>",
	"overview": "В этом разделе объясняются концепции, которые имеют решающее значение для понимания <b>функций</b>.",

	"definition": {
		"name": "Определение",
		"page_1": [
			"<b>Определение функции</b> \nФункция определяет действия, которые выполняет программа. Функции позволяют выделить набор инструкций и придать ему имя. А затем многократно по присвоенному имени вызывать в различных частях программы. По сути функция - это именованный блок кода.",
			"Формальное определение функции выглядит следующим образом:\n<code>type function_name(parameters) \n{ \ninstructions \n}</code> \nПервая строка представляет заголовок функции. Вначале указывается возвращаемый тип функции. Если функция не возвращает никакого значения, то используется тип <b>void</b>.",
			"Затем идет имя функции, которое представляет произвольный идентификатор. К именованию функции применяются те же правила, что и к именованию переменных. \nПосле имени функции в скобках идет перечисление параметров. Функция может не иметь параметров, в этом случае указываются пустые скобки.",
			"После заголовка функции в фигурных скобках идет тело функции, которое содержит выполняемые инструкции. \nДля возвращения результата функция применяет оператор <b>return</b>. Если функция имеет в качестве возвращаемого типа любой тип, кроме void, то она должна обязательно с помощью оператора return возвращать какое-либо значение.",
			"Например, определение функции main, которая должна быть в любой программе на языке C++ и с которой начинается ее выполнение: \n<code>int main() \n{ \nreturn 0; \n}</code> \nВозвращаемым типом функции является тип <b>int</b>, поэтому функция должна использовать оператор <b>return</b> и возвращать какое-либо значение, которое соответствует типу int. Возвращаемое значение ставится после оператора return.",
			"Но если функция имеет тип <b>void</b>, то ей не надо ничего возвращать. Например, мы могли бы определить следующую функцию: \n<code>void hello() \n{ \nstd::cout &lt;&lt; 'hello\n'; \n}</code>",
			"<b>Выполнение функции</b> \nДля выполнения функции ее необходимо вызвать. Вызов функции осуществляется в форме: \n<code>имя_функции(аргументы);</code> \nПосле имени функции указываются скобки, в которых перечисляются аргументы - значения для параметров функции.",
			"Например, определим и выполним простейшую функцию: \n<code>#include &lt;iostream&gt; \nvoid hello() \n{ \nstd::cout &lt;&lt; 'hello\n'; \n} \nint main() \n{ \nhello(); \nhello(); \nreturn 0; \n}</code>",
			"В этом случае перед вызовом функции надо ее дополнительно объявить. Объявление функции еще называют прототипом. Формальное объявление выглядит следующим образом: \n<code>тип имя_функции(параметры);</code> \nФактически это заголовок функции. То есть для функции hello объявление будет выглядеть следующим образом:",
			"<code>void hello();</code> \nWe use the function declaration: \n<code>#include &lt;iostream&gt; \nvoid hello(); \nint main() \n{ \nhello(); \nhello(); \nreturn 0; \n} \nvoid hello() \n{ \nstd::cout &lt;&lt; 'hello\n'; \n}</code>",
			"В данном случае несмотря на то, что определение функции идет после ее вызова, но так как функция уже объявлена до ее вызова, то компилятор уже будет знать о функции hello, и никаких проблем в работе программы не возникнет."
		]
	},

	"function_parameters": {
		"name": "Параметры функции",
		"page_1": [
			"Через параметры в функцию можно передать различеые значения. Параметры перечисляются в скобках после имени функции имеют следующее определение: \n<code>тип название_параметра</code> \nНапример, определим программу обменного пункта:",
			"<code>#include &lt;iostream&gt; \nvoid exchange(double, double); \nint main() \n{ \ndouble rate = 58; \ndouble sum = 5000; \nexchange(rate, sum); \nexchange(60, 5000); \nreturn 0; \n} \nvoid exchange(double currate, double sum) \n{ \ndouble result = sum / currate; \nstd::cout &lt;&lt;  'Rate: ' &lt;&lt; currate &lt;&lt; '\tSum: ' &lt;&lt; sum &lt;&lt; '\tResult: ' &lt;&lt; result &lt;&lt; std::endl; \n}</code>",
			"При запуске программы мы получим следующий консольный вывод: \n<b>Rate: 58 \nSum: 5000 \nResult: 86.2069 \nRate: 60 \nSum: 5000 \nResult: 83.3333</b> \nФункция exchange принимает два параметра типа double, которые называются currate (текущий курс) и sum (сумма, которую надо обменять).",
			"При вызове функции exchange для этих параметров необходимо передать значения. Значения, передаваемые параметрам функции при ее вызове, называются аргументами. В данном случае в качестве аргументов передаются обычные числа. При этом аргументы передаются по позиции, то есть первый аргумент передается перому параметру, второй аргумент - второму параметру и так далее. При этом аргументы должны соответствовать параметрам по типу или допускать неявно преобразование в тип параметра.",
			"Рассмотрим еще один пример с функциями: \n<code>#include &lt;iostream&gt; \n#include &lt;string&gt; \nvoid square(int); \nvoid display(std::string, int); \nint main() \n{  \ndisplay('Tom', 33); \nsquare(4.56); \nreturn 0; \n} \nvoid square(int x) \n{ \nstd::cout &lt;&lt; 'Square of ' &lt;&lt; x &lt;&lt; ' is equal to ' &lt;&lt; x * x &lt;&Lt; std::endl; \n} \nvoid display(std::string name, int age) \n{ \nstd::cout &Lt;&lt; 'Name: ' &lt;&lt; name &lt;&lt; '\tAge: ' &Lt;&Lt; age &Lt;&Lt; std::endl; \n}</code>",
			"Функция display принимает параметры типов string и int. При вызове этой функции в нее вначале передается строка ('Tom'), так как параметр типа string идет первым, а потом число (33), так как параметр типа int идет вторым: display('Tom', 33)",
			"Функция square принимает число и выводит на консоль его квадрат. Параметр функции представляет тип int, однако при ее вызове ей передается число с плавающей точкой, то есть значение типа double. Поэтому производится преобразование от типа double к типу int, дробная часть отбрасывается, и в итоге функция получает число 4."
		],

		"page_2": [
			"<b>Аргументы по умолчанию</b> \nФункция может принимать аргументы по умолчанию, то есть некоторые значения, которые функция использует, если при вызове для параметров явным образом не передается значение:",
			"<code>#include &lt;iostream&gt; \nvoid multiply(int n, int m = 3) \n{ \nint result = n * m; \nstd::cout &lt;&lt; 'n * m = ' &lt;&lt; result &lt;&lt; std::endl; \n} \nint main() \n{ \nmultiply(4, 5); \nmultiply(4); \nreturn 0; \n}</code>",
			"Для установки значения по умолчанию параметру присваивается это значение int m = 3. И если для второго параметра не будет передано значение, то он будет использовать значение по умолчанию. Консольный вывод программы: \n<b>n * m = 20 \nn * m = 12",
			"При объявлении прототипа подобной функции он тоже может содержать значение по умолчанию для параметра. И в этом случае мы можем не определять в функции значение по умолчанию для параметра - оно будет браться из прототипа: \n<code>#include &lt;iostream&gt; \nvoid multiply(int n, int m=3); \nint main() \n{ \nmultiply(4, 5); \nmultiply(4); \nreturn 0; \n} \nvoid multiply(int n, int m) \n{ \nint result = n * m; \nstd::cout &lt;&lt; 'n * m = ' &lt;&lt; result &lt;&lt; std::endl; \n}</code>"
		]
	}
}
