{
	"id": "functions",
	"name": "<b>Функции</b>",
	"overview": "В этом разделе объясняются концепции, которые имеют решающее значение для понимания <b>функций</b>.",

	"definition": {
		"name": "Определение",
		"page_1": [
			"<b>Определение функции</b> \nФункция определяет действия, которые выполняет программа. Функции позволяют выделить набор инструкций и придать ему имя. А затем многократно по присвоенному имени вызывать в различных частях программы. По сути функция - это именованный блок кода.",
			"Формальное определение функции выглядит следующим образом:\n<code>type function_name(parameters) \n{ \ninstructions \n}</code> \nПервая строка представляет заголовок функции. Вначале указывается возвращаемый тип функции. Если функция не возвращает никакого значения, то используется тип <b>void</b>.",
			"Затем идет имя функции, которое представляет произвольный идентификатор. К именованию функции применяются те же правила, что и к именованию переменных. \nПосле имени функции в скобках идет перечисление параметров. Функция может не иметь параметров, в этом случае указываются пустые скобки.",
			"После заголовка функции в фигурных скобках идет тело функции, которое содержит выполняемые инструкции. \nДля возвращения результата функция применяет оператор <b>return</b>. Если функция имеет в качестве возвращаемого типа любой тип, кроме void, то она должна обязательно с помощью оператора return возвращать какое-либо значение.",
			"Например, определение функции main, которая должна быть в любой программе на языке C++ и с которой начинается ее выполнение: \n<code>int main() \n{ \nreturn 0; \n}</code> \nВозвращаемым типом функции является тип <b>int</b>, поэтому функция должна использовать оператор <b>return</b> и возвращать какое-либо значение, которое соответствует типу int. Возвращаемое значение ставится после оператора return.",
			"Но если функция имеет тип <b>void</b>, то ей не надо ничего возвращать. Например, мы могли бы определить следующую функцию: \n<code>void hello() \n{ \nstd::cout &lt;&lt; 'hello\n'; \n}</code>",
			"<b>Выполнение функции</b> \nДля выполнения функции ее необходимо вызвать. Вызов функции осуществляется в форме: \n<code>имя_функции(аргументы);</code> \nПосле имени функции указываются скобки, в которых перечисляются аргументы - значения для параметров функции.",
			"Например, определим и выполним простейшую функцию: \n<code>#include &lt;iostream&gt; \nvoid hello() \n{ \nstd::cout &lt;&lt; 'hello\n'; \n} \nint main() \n{ \nhello(); \nhello(); \nreturn 0; \n}</code>",
			"В этом случае перед вызовом функции надо ее дополнительно объявить. Объявление функции еще называют прототипом. Формальное объявление выглядит следующим образом: \n<code>тип имя_функции(параметры);</code> \nФактически это заголовок функции. То есть для функции hello объявление будет выглядеть следующим образом:",
			"<code>void hello();</code> \nWe use the function declaration: \n<code>#include &lt;iostream&gt; \nvoid hello(); \nint main() \n{ \nhello(); \nhello(); \nreturn 0; \n} \nvoid hello() \n{ \nstd::cout &lt;&lt; 'hello\n'; \n}</code>",
			"В данном случае несмотря на то, что определение функции идет после ее вызова, но так как функция уже объявлена до ее вызова, то компилятор уже будет знать о функции hello, и никаких проблем в работе программы не возникнет."
		]
	},

	"function_parameters": {
		"name": "Параметры функции",
		"page_1": [
			"Через параметры в функцию можно передать различеые значения. Параметры перечисляются в скобках после имени функции имеют следующее определение: \n<code>тип название_параметра</code> \nНапример, определим программу обменного пункта:",
			"<code>#include &lt;iostream&gt; \nvoid exchange(double, double); \nint main() \n{ \ndouble rate = 58; \ndouble sum = 5000; \nexchange(rate, sum); \nexchange(60, 5000); \nreturn 0; \n} \nvoid exchange(double currate, double sum) \n{ \ndouble result = sum / currate; \nstd::cout &lt;&lt;  'Rate: ' &lt;&lt; currate &lt;&lt; '\tSum: ' &lt;&lt; sum &lt;&lt; '\tResult: ' &lt;&lt; result &lt;&lt; std::endl; \n}</code>",
			"При запуске программы мы получим следующий консольный вывод: \n<b>Rate: 58 \nSum: 5000 \nResult: 86.2069 \nRate: 60 \nSum: 5000 \nResult: 83.3333</b> \nФункция exchange принимает два параметра типа double, которые называются currate (текущий курс) и sum (сумма, которую надо обменять).",
			"При вызове функции exchange для этих параметров необходимо передать значения. Значения, передаваемые параметрам функции при ее вызове, называются аргументами. В данном случае в качестве аргументов передаются обычные числа. При этом аргументы передаются по позиции, то есть первый аргумент передается перому параметру, второй аргумент - второму параметру и так далее. При этом аргументы должны соответствовать параметрам по типу или допускать неявно преобразование в тип параметра.",
			"Рассмотрим еще один пример с функциями: \n<code>#include &lt;iostream&gt; \n#include &lt;string&gt; \nvoid square(int); \nvoid display(std::string, int); \nint main() \n{  \ndisplay('Tom', 33); \nsquare(4.56); \nreturn 0; \n} \nvoid square(int x) \n{ \nstd::cout &lt;&lt; 'Square of ' &lt;&lt; x &lt;&lt; ' is equal to ' &lt;&lt; x * x &lt;&Lt; std::endl; \n} \nvoid display(std::string name, int age) \n{ \nstd::cout &Lt;&lt; 'Name: ' &lt;&lt; name &lt;&lt; '\tAge: ' &Lt;&Lt; age &Lt;&Lt; std::endl; \n}</code>",
			"Функция display принимает параметры типов string и int. При вызове этой функции в нее вначале передается строка ('Tom'), так как параметр типа string идет первым, а потом число (33), так как параметр типа int идет вторым: display('Tom', 33)",
			"Функция square принимает число и выводит на консоль его квадрат. Параметр функции представляет тип int, однако при ее вызове ей передается число с плавающей точкой, то есть значение типа double. Поэтому производится преобразование от типа double к типу int, дробная часть отбрасывается, и в итоге функция получает число 4."
		],

		"page_2": [
			"<b>Аргументы по умолчанию</b> \nФункция может принимать аргументы по умолчанию, то есть некоторые значения, которые функция использует, если при вызове для параметров явным образом не передается значение:",
			"<code>#include &lt;iostream&gt; \nvoid multiply(int n, int m = 3) \n{ \nint result = n * m; \nstd::cout &lt;&lt; 'n * m = ' &lt;&lt; result &lt;&lt; std::endl; \n} \nint main() \n{ \nmultiply(4, 5); \nmultiply(4); \nreturn 0; \n}</code>",
			"Для установки значения по умолчанию параметру присваивается это значение int m = 3. И если для второго параметра не будет передано значение, то он будет использовать значение по умолчанию. Консольный вывод программы: \n<b>n * m = 20 \nn * m = 12",
			"При объявлении прототипа подобной функции он тоже может содержать значение по умолчанию для параметра. И в этом случае мы можем не определять в функции значение по умолчанию для параметра - оно будет браться из прототипа: \n<code>#include &lt;iostream&gt; \nvoid multiply(int n, int m=3); \nint main() \n{ \nmultiply(4, 5); \nmultiply(4); \nreturn 0; \n} \nvoid multiply(int n, int m) \n{ \nint result = n * m; \nstd::cout &lt;&lt; 'n * m = ' &lt;&lt; result &lt;&lt; std::endl; \n}</code>"
		]
	},
	"arguments_by_value/links":{
		"name":arguments_by_value,
		"page_1":[
			"Arguments can be passed by value and by reference. When passing arguments by value, the external object that is passed as an argument to a function cannot be modified in that function. The value of this object is passed to the function. For example:"
			"<code>#include &lt;iostream&gt; /nvoid square(int, int); /nint main() /n{ /nint a = 4; /nint b = 5; /n std::cout &lt;&lt; "Before square: a = " &lt;&lt; a &lt;&lt; "\tb=" &lt;&lt; b &lt;&lt; std::endl; /nsquare(a, b); /nstd::cout &lt;&lt; "After square: a = " &lt;&lt; a &lt;&lt; "\tb=" &lt;&lt; b &lt;&lt; std::endl; /nreturn 0; /n} /nvoid square(int a, int b) /n{ /na = a * a;  /nb = b * b; /nstd::cout &lt;&lt; "In square: a = " &lt;&lt; a &lt;&lt; "\tb=" &lt;&lt; b &lt;&lt; std::endl; /n} /n}
			"The square function takes two numbers and squares them. In the main function, before and after the execution of the square function, the values of the variables a and b are printed to the console, which are passed to square as arguments.
			"And when we run, we will see that the changes to the arguments in the square function only take effect within that function. Outside of it, the values of the variables a and b remain unchanged:"
			"<b>Before square: a = 4 	b = 5 /nIn square: a = 16		b = 25 /n	After square: a = 4 	b = 5</b>"
			"Why it happens? When compiling a function, separate sections of memory are allocated for its parameters. When the function is called, the values of the arguments are calculated, which are passed in place of the parameters. And then the values of the arguments are entered into these memory chunks. That is, the function manipulates copies of the values of objects, not the objects themselves."
		"name":arguments_by_links,
		"page_1":[
			"When passing parameters by reference, a reference to the object is passed through which we can manipulate the objects themselves, and not just its value. So, let's rewrite the previous example using pass by reference:"
			"<code>#include <iostream> /nvoid square(int&, int&); /nint main() /n{ /nint a = 4; /nint b = 5; /nstd::cout << "Before square: a = " << a << "\tb=" << b << std::endl; /nsquare(a, b); .nstd::cout << "After square: a = " << a << "\tb=" << b << std::endl; /nreturn 0; /n} /nvoid square(int &a, int &b) /n{ /na = a * a; /nb = b * b; /nstd::cout << "In square: a = " << a << "\tb=" << b << std::endl; /n}"
			"Now parameters a and b are passed by reference. The reference parameter is linked directly to the object, so the object itself can be changed through the reference.And if we compile and run the program, the result will be different:"
			"<b>Before square: a = 4 	b = 5 /nIn square: a = 16		b = 25 /nAfter square: a = 16 	b = 25</b>"
			"Passing by reference allows you to return multiple values ​​from a function at once. Also, passing parameters by reference is more efficient when passing very large objects. Since in this case there is no copying of values, and the function uses the object itself, not its value.Passing arguments by reference should be distinguished from passing references as arguments:"
			"<code>#include <iostream> /nvoid square(int, int); /nint main() /n{ /nint a = 4; /nint b = 5; /nint &aRef = a; /nint &bRef = b; /nstd::cout << "Before square: a = " << a << "\tb=" << b << std::endl; /nsquare(aRef, bRef); /nstd::cout << "After square: a = " << a << "\tb=" << b << std::endl; /nreturn 0; /n} /nvoid square(int a, int b) /n{ /na = a * a; /nb = b * b; /nstd::cout << "In square: a = " << a << "\tb=" << b << std::endl; /n}
			"If a function takes arguments by value, then changing parameters inside the function will also have no effect on external objects, even if object references are passed to it when the function is called."
			"Before square: a = 4 	b = 5 /nIn square: a = 16		b = 25 /nAfter square: a = 4 	b = 5;"
			"Passing parameters by value is more suitable for passing small objects to a function, the values ​​of which are copied to certain areas of memory, which are then used by the function. Passing parameters by reference is more suitable for passing large objects to a function; in this case, you do not need to copy the entire contents of the object into a memory location, which increases the performance of the program."
