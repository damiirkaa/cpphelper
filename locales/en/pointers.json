{
	"id": pointers",
	"name": "<b>Pointers</b>",
	"overview": "This section explains concepts that are critical to understanding <bpointers</b>",

	"definition": 
	{
		"name": "Definition",
		"page_1": 
		[
    "Pointers are objects whose values are addresses of other objects (variables, constants, pointers) or functions. Like references, pointers are used to access an object indirectly. However, unlike references, pointers have more features.",
    "To define a pointer, you must specify the type of object to which the pointer points and the asterisk symbol *. For example, let's define a pointer to an object of type int: \n<code>int *p;</code> \nAs long as the pointer does not refer to any object. Unlike a reference, a pointer does not need to be initialized with a value. Now let's assign a variable address to the pointer:",
    "<code>int x = 10; // define a variable \nint *p; // determine the pointer \np = &x; // the pointer gets the variable address</code> \nTo get the address of a variable, the <b>&</b> operation is used. Importantly, the variable x is of type int, and the pointer that points to its address is also of type int. That is, there must be a type match.",
    "If we try to display the address of the variable on the console, we see that it represents a hexadecimal value: \n<code>#include &lt;iostream&gt; \nint main() \n{ \nint x = 10; // determine the variable \nint *p; // determine the pointer \np = &x; // the pointer gets the variable address \nstd::cout &lt;&lt; "p = " &lt;&lt; p &lt;&lt; std::endl; \nreturn 0; \n}</code>"m,
    "Console program output: \n<b>p = 0x60fe98</b> \nThe address may be different in each case, but for example, in my case, the machine address of the variable x is 0x60fe98. That is, the computer has an address 0x60fe98 in memory where variable x is located. Since the variable x represents <b>int</b> type, on most architectures it will occupy the next 4 bytes (on specific architectures the memory size for int type may differ). Thus a variable of int type will successively occupy memory cells with addresses 0x60FE98, 0x60FE99, 0x60FE9A, 0x60FE9B.",And the p pointer will refer to the address where the variable x is located, i.e. address 0x60FE98.",
    "And the <b>p</b> pointer will refer to the address where the variable x is located, i.e. address 0x60FE98. \nBut since a pointer stores an address, we can use this address to get the value stored there, that is, the value of the variable x. To do this we use the operation * or dereferencing, which is the same operation that is used when defining a pointer. The result of this operation is always the object to which the pointer points. We apply this operation and obtain the value of the variable x:",
    "<code>#include &lt;iostream&gt; \nint main() \n{ \nint x = 10; \nint *p; \np = &x; \nstd::cout &lt;&lt; "Address = " &lt;&lt; p &lt;&lt; std::endl; \nstd::cout &lt;&Lt; "Value = " &lt;&lt; *p &lt;&lt; std::endl; \nreturn 0; \n}</code> \nConsole output: \n<b>Address = 0x60fe98 \nValue = 10</b> \nThe value resulting from the dereferencing operation can be assigned to another variable:",
    "<code>int x = 10; \nint *p  = &x; \nint y = *p; \nstd::cout &lt;&lt; "Value = " &lt;&lt; y &lt;&lt; std::endl;    // 10</code> \nAnd also using a pointer we can change the value at the address stored in the pointer:",
    "<code>int x = 10; \nint *p = &x; \n*p = 45; \nstd::cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; std::endl;     // 45</code> \nSince the variable x is located at the address the pointer points to, its value will change accordingly. \nLet's create some more pointers:",
    "<code>#include &lt;iostream&gt; \nint main() \n{ \nshort c = 12; \nint d = 10; \nshort s = 2; \nshort *pc = &ampc;          // get the address of the variable with the type short \nint *pd = &ampd;           // get the address of variable d of int type \nshort *ps = &amps;         // get the address of the variable s of the short type \nstd::cout &lt;&lt; "Variable c: address=" &lt;&lt; pc &lt;&lt; "\t value=" &lt;&lt; *pc &lt;&lt; std::endl; \nstd::cout &lt;&lt; "Variable d: address=" &lt;&lt; pd &lt;&lt; "\t value=" &lt;&lt; *pd &lt;&lt; std::endl; \nstd::cout &lt;&lt; "Variable s: address=" &lt;&lt; ps &lt;&lt; "\t value=" &lt;&lt; *ps &lt;&lt; std::endl; \nreturn 0; \n}</code>",
    "In my case I get the following console output: \n<b>Variable c: address=0x60fe92	value=12 \nVariable d: address=0x60fe8c	value=10 \nVariable s: address=0x60fe8a	value=2</b>"
    ],
    
    "page_2":
    [
    "<b>Operations with pointers</b> \nPointers support a number of operations: assignment, get pointer address, get value by pointer, some arithmetic operations and comparison operations.",
    "<b>Assignment</b> \nYou can either assign an address to an object of the same type or the value of another pointer. \nAssigning an address to a pointer has already been discussed in the previous topic. To get the address of an object the <b>&</b> operation is used:",
    "<code>int a = 10; \nint *pa = &ampa; // the pa pointer stores the address of the a variable</code> \nA pointer and a variable must have the same type, in this case it is type int. \nAssigning a pointer to another pointer:",
    "<code>#include &lt;iostream&gt; \nusing std::cout; \nusing std::endl; \nint main() \n{ \nint a = 10; \nint b = 2; \nint *pa = &ampa; \nint *pb = &ampb; \ncout &lt;&lt; "Variable a: address=" &lt;&Lt; pa &lt;&lt; "\t value=" &lt;&Lt; *pa &lt;&Lt; endl; \ncout &Lt;&Lt; "Variable b: address=" &lt;&Lt; pb &lt;&Lt; "\t value=" &lt;&lt; *pb &lt;&lt; endl; \npa = pb;    // now the pointer pa stores the address of the variable b \ncout &lt;&lt; "Variable b: address=" &lt;&lt; pa &lt;&lt; "\t value=" &lt;&lt; *pa &lt;&lt; endl; \nreturn 0; \n}</code>",
    "When a pointer is assigned to another pointer, in fact the first pointer also starts pointing to the same address as the second pointer. \n<b>Zero pointers</b> \nA null pointer is a pointer that doesn't point to any object. If we don't want the pointer to point to any particular address, we can assign it a conditional null value. There are various ways to create a null pointer:",
    "<code>int *p1 = nullptr; \nint *p2 = NULL; \nint *p3 = 0;</code> \n<b>References to pointers</b> \nSince a reference is not an object, you cannot define a pointer to a reference, but you can define a reference to a pointer. Through such a reference you can change the value to which the pointer points or change the address of the pointer itself:",
    "<code>#include &lt;iostream&gt; \nint main() \n{ \nint a = 10 \nint b = 6; \nint *p = 0; // pointer \nint *&amppRef = p; // reference to the pointer \npRef = &ampa; // the address of the a variable is assigned to the p pointer by reference \nstd::cout << "p value=" &lt;&lt; *p &lt;&lt; std::endl; // 10 \n*pRef = 70; // change the value at the pointer address \nstd::cout << "a value=" &lt;&Lt; a &Lt;&Lt; std::endl; // 70 \npRef = &b; // change the address, pointed by the pointer \nstd::cout &lt;&lt; "p value=" &lt;&lt; *p &lt;&Lt; std::endl; // 6 \nreturn 0; \n}</code>"
    ]
    
    "page_3":
    [
    "<b>Pointer dereferencing</b> \nThe pointer dereferencing operation represents an expression in the form *pointer_name. This operation retrieves an object by the address stored in the pointer.",
    "<code>#include &lt;iostream&gt; \nusing std::cout; \nusing std::endl; \nint main() \n{ \nint a = 10; \nint *pa = &a; \nint *pb = pa; \n*pa = 25; \ncout &lt;&lt; "Value on pointer pa: " &lt;&lt; *pa &lt;&lt; endl;  // 25 \ncout &lt;&lt; "Value on pointer pb: " &lt;&lt; *pb &lt;&lt; endl;  // 25 \ncout &lt;&lt; "Value of variable a: " &lt;&lt; a &lt;&lt; endl;    // 25 \nreturn 0; \n}</code>",
    "With the expression *pa we can get the value at the address stored in the pointer pa, and with an expression of type *pa = value we can put a new value at that address. \nAnd since in this case the pointer pa points to the variable a, when you change the value at the address to which the pointer points, the value of the variable a will also change.",
    "<b>Pointer address</b> \nA pointer stores the address of a variable, and at this address we can get the value of this variable. But moreover, a pointer, like any variable, itself has an address where it is located in memory. This address can also be obtained via the <b>&amp</b> operation:",
    "<code>int a = 10; \nint *pa = &ampa; \nstd::cout &lt;&lt; "address of pointer=" &lt;&lt; &amppa &lt;&lt; std::endl; // pointer address \nstd::cout &lt;&lt; "address stored in pointer=" &lt;&lt; pa &lt;&lt; std::endl; // the address stored in the pointer is the address of a variable          \nstd::cout &lt:&lt; "value on pointer=" &lt;&lt; *pa &lt;&Lt; std::endl; // value at the pointer address is the value of a variable</code>",
    "<b>Comparison operations</b> \nComparison operations <b>&gt;, &gt;=, &lt;, &lt;=,==, !=</b> can be applied to pointers. Comparison operations are applied only to pointers of the same type and to the values <b>NULL</b> and <b>nullptr</b>. Address numbers are used for comparison:",
    "<code>#include &lt;iostream&gt; \nusing std::cout; \nusing std::endl; \nint main() \n{ \nint a = 10; \nint b = 20; \nint *pa = &ampa; \nint *pb = &ampb; \nif(pa &gt; pb) \ncout &lt;&lt; "pa (" &lt;&lt; pa &lt;&lt; ") is greater than pb ("&lt;&lt; pb &lt;&lt; ")" &lt;&lt; endl; \nelse \ncout &lt;&lt; "pa (" &lt;&lt; pa &lt;&lt; ") is less or equal pb ("&lt;&lt; pb &lt;&lt; ")" &lt;&lt; endl; \nreturn 0; \n}</code>",
    "Console output in my case: \n<b>pa (0x60fe94) is greater than pb (0x60fe90)</b> \n<b>Citing types</b> \nSometimes you need to assign a pointer of one type to a pointer of another type. In this case you should perform a type conversion using the (pointer_type*) operation: \n<code>#include &lt;iostream&gt; \nint main() \n{ \nchar c = 'N'; \nchar *pc = &ampc; \nint *pd = (int *)pc; \nvoid *pv = (void*)pc; \nstd::cout &lt;&lt; "pv=" &lt;&Lt; pv &lt;&lt; std::endl; \nstd::cout &lt;&lt; "pd=" &lt;&lt; pd &Lt;&Lt; std::endl; \nreturn 0; \n}</code>",
    "To convert a pointer to another type, put the type you want to convert to in parentheses before the pointer. And if we cannot create an object, for example, a <i>void</i> type variable, it will work for a pointer. That is, it is possible to create a <i>void</i> type pointer. \nIn addition, it should be noted that the system interprets a pointer to <i>char</i> type (char *pc = &ampc) as a string when output to the console: <code>std::cout &lt;&lt; "pc=" &lt;&lt; pc &lt;&lt; std::endl;</code>",
    "Therefore, if we still want to output an address to the console that is stored in a char pointer, the pointer must be converted to another type, such as void* or int*.t*."
    ]
    }



