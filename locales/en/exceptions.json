{
	"id": "exceptions",
	"name": "<b>Exceptions</b>",
	"overview": "This section explains concepts that are critical to understanding <b>exceptions</b>",

	"exception_handling": 
	{
		"name": "Exception handling",
		"page_1":
    [
    "Various errors may occur while the program is running. For example, when transferring a file over the network, the network connection is lost or invalid or invalid data are entered that cause the program to crash. Such errors are also called exceptions. If an exception is not handled, the program stops when it occurs. \nFor example, in the following program the numbers are divided:",
    "<code>#include &lt;iostream&gt; \ndouble divide(int, int); \nint main() \n{ \nint x = 500; \nint y = 0; \ndouble z = divide(x, y); \nstd::cout &lt;&lt; z &lt;&lt; std::endl; \nstd::cout &lt;&lt; 'The End...' &lt;&lt; std::endl; \nreturn 0; \n} \ndouble divide(int a, int b) \n{ \nreturn a / b; \n}</code>",
    "This program will compile successfully, but there will be an error when it runs, because the code performs division by zero, after which the program will crash. \nOn the one hand, we can define a check in the divide function and do division if the parameter b is not equal to 0. But in any case, we need to return some result from the divide function - some number. That is, we cannot just write:",
    "<code>double divide(int a, int b) \n{ \nif (b != 0) \nreturn a / b; \nelse \nstd::cout &lt;&lt; 'Error! b must not be equal to 0' &lt;&lt; std::endl; \n}</code> \nAnd in this case we need to notify the system about the error. For this purpose the <b>throw</b> operator is used.",
    "The <b>throw</b> operator generates an exception. The throw operator can be used to pass information about the error. For example, the divide function might look like this: \n<code>double divide(int a, int b) \n{ \nif (b == 0) \nthrow "Division by zero!"; \nreturn a / b; \n}</code>",
    "That is, if parameter b is 0, then we generate an exception. \nBut this exception must be handled in the code where divide function will be called. To handle exceptions the <b>try...catch</b> construct is used. It has the following form: \n<code>try \n{ \ninstructions that may raise an exception \n} \ncatch(declaration_exception) \n{ \nexception handling \n}</code>",
    "The block after the <b>try</b> keyword contains code that can potentially generate an exception. \nAfter <b>catch</b> keyword in brackets there is parameter which transfers information about exception. Then the exception handling itself is performed in the block. \nSo let's change the whole code as follows:",
    "<code>#include &lt;iostream&gt; \ndouble divide(int, int); \nint main() \n{ \nint x = 500; \nint y = 0; \ntry \n{ \ndouble z = divide(x, y); \nstd::cout &lt;&lt; z &lt;&lt; std::endl; \n} \ncatch (...) \n{ \nstd::cout &lt;&lt; 'Error!' &lt;&lt; std::endl; \n} \nstd::cout &lt;&lt; 'The End...' &lt;&lt; std::endl; \nreturn 0; \n} \ndouble divide(int a, int b) \n{ \nif (b == 0) \nthrow "Division by zero!"; \nreturn a / b; \n}</code>",
    "The code that could potentially generate an exception, a divide function call, is placed in the try block. \nIn the catch block an exception is handled. And the ellipsis in brackets after catch(...) operator allows to handle any exception.",
    "As the result, when program's execution reaches line double z = divide(x, y); an exception will be generated, so further instructions from try block will not be executed, and control will go to catch block, where error message will be shown on the console. After catch block the program will not crash, but will continue its work, executing statements after catch block: \n<b>Error! \nThe End...</b>",
    "To compile this example with try...catch with g++ you may need to use the <i>-static</i> flag: \n<b>g++ app.cpp -o app -static</b> \nIn this case, however, we only know that an error has occurred, and we don't know what kind of error it is. Therefore, in the catch expression we can get the message that is passed to the throw operator:",
    "<code>int main() \n{ \nint x = 500; \nint y = 0; \ntry \n{ \ndouble z = divide(x, y); \nstd::cout &lt;&lt; z &lt;&lt; std::endl; \n} \ncatch (const char* msg) \n{ \nstd::cout &lt;&lt; msg &lt;&lt; std::endl; \n} \nstd::cout &lt;&lt; 'The End...' &lt;&lt; std::endl; \nreturn 0; \n}</code>",
    "Using the const char* msg parameter we get the message that is passed to the throw operator and outputs this message to the console. And in this case the console output will look like this: \n<b>Division by zero! \nThe End...</b> \nIn this way, we can learn the essence of the exception that has arisen."
    ]
    },
    
    "exception_type":
    {
    "name": "Exception type",
    "page_2":
    [
    "All exceptions in C++ are described by the <b>exception</b> type which is defined in the <b>&lt;exception&gt;</b> header file. And when handling exceptions we can use this class too. For example:",
    "<code>#include &lt;iostream&gt; \n#include &lt;exception&gt; \ndouble divide(int, int); \nint main() \n{ \nint x = 500; \nint y = 0; \ntry \n{ \ndouble z = divide(x, y); \nstd::cout &lt;&lt; z &lt;&lt; std::endl; \n} \ncatch (const std::exception& err) \n{ \nstd::cout &lt;&lt; "Error!!!" &lt;&lt; std::endl; \n} \nstd::cout &lt;&lt; "The End..." &lt;&lt; std::endl; \nreturn 0; \n} \ndouble divide(int a, int b) \n{ \nif (b == 0) \nthrow std::exception(); \nreturn a / b; \n}</code>",
    "First of all, an object of type <b>std::exception</b> is passed to the throw operator. This object is initialized with the string 'Division by zero!', which conveys information about the nature of the error.",
    "<code>throw std::exception("Division by zero!");</code> \nIf we want to catch exceptions of the exception type, we have to define a variable of this type in the catch expression: \n<code>catch (const std::exception& err)</code>",
    "That is, here err represents a variable of type exception. It is not necessary to define a variable exactly as a constant reference, you can define it that way: \n<code>catch (std::exception err)</code> \nIf we don't intend to use this variable in the catch block, we can simply specify the exception type:",
    "<code>catch (std::exception) \n{ \nstd::cout &lt;&lt; "errrorr" &lt;&lt; std::endl; \n}</code> \nIt is also worth noting the differences in compiler implementations. For example, Visual Studio allows you to initialize an exception object with a string. For example, it is possible to pass an error message:",
    "<code>#include &lt;iostream&gt; \n#include &lt;exception&gt; \ndouble divide(int, int); \nint main() \n{ \nint x = 500; \nint y = 0; \ntry \n{ \ndouble z = divide(x, y); \nstd::cout &lt;&lt; z &lt;&lt; std::endl; \n} \ncatch (std::exception err) \n{ \nstd::cout &lt;&lt; err.what() &lt;&lt; std::endl; \n} \nstd::cout &lt;&lt; "The End..." &lt;&lt; std::endl; \nreturn 0; \n} \ndouble divide(int a, int b) \n{ \nif (b == 0) \nthrow std::exception("Division by zero!"); \nreturn a / b; \n}</code>",
    "You can use the <b>what()</b> method in the catch block to retrieve the passed message and display it on the console, for example: \n<code>catch (std::exception err) \n{ \nstd::cout &lt;&lt; err.what() &lt;&lt; std::endl; \n}</code> \nBut this code will not work in g++ because the exception type for g++ cannot be initialized by string."
    ]
    }
