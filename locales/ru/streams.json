{
	"id": "streams",
	"name": "<b>Потоки</b>",
	"overview": "В этом разделе объясняются концепции, которые имеют решающее значение для понимания <b>потоков</b>.",

	"basic_types": 
	{
		"name": "Базовые типы",
		"page_1": 
		[
		"Все инструменты для работы с системой ввода-вывода и потоками в языке С++ определены в стандартной библиотеке. Заголовочный файл iostream определяет следующие базовые типы для работы с потоками:",
		"<b>istream</b> и <b>wistream</b>: читают данные с потока \no<b>stream</b> и <b>wostream</b>: записывают данные в поток \n<b>iostream</b> и <b>wiostream</b>: читают и записывают данные в поток \nДля каждого типа определен его двойник, который начинается на букву w и который предназначен для поддержки данных типа wchar_t.",
		"Эти типы являются базовыми для других классов, управляющих потоками ввода-вывода. \nОбъект типа <b>ostream</b> получает значения различных типов, преобразует их в последовательность символов и передает их через буфер в определенное место для вывода (консоль, файл, сетевые интерфейсы и т.д.)",
		"Поток <b>istream</b> получает через буфер из определенного места последовательности символов (с консоли, из файла, из сети и т.д.) и преобразует эти последовательности в значения различных типов. То есть когда мы вводим данные (с той же клавиатуры в консоли), сначала данные накапливаются в буфере и только затем передаются объекту istream.",
		"По умолчанию в стандартной библиотеке определены объекты этих классов - <b>cout, cin, cerr,</b> которые работают с консолью. \n<b>Запись в поток</b> \nДля записи данных в поток ostream применяется оператор <b>&lt;&lt;</b>. Этот оператор получает два операнда. Левый операнд представляет объект типа ostream, а правый операнд - значение, которое надо вывести в поток.",
		"К примеру, по умолчанию стандартная библиотека C++ предоставляет объект <b>cout</b>, который представляет тип ostream и позволяет выводить данные на консоль: \n<code>#include &lt;iostream&gt; \nint main() \n{ \n    std::cout &lt;&lt; 'Hello' &lt;&lt; std::endl; \n    return 0; \n}</code> \nТак как оператор <b>&lt;&lt;</b> возвращает левый операнд - cout, то с помощью цепочки операторов мы можем передать на консоль несколько значений:",
		"<code>std::cout &lt;&lt; 'Hello' &lt;&lt; ' world' &lt;&lt; std::endl;</code> \n<b>Чтение данных</b> \nДля чтения данных из потока применяется оператор ввода <b>&gt;&gt;</b>, который принимает два операнда. Левый операнд представляет поток istream, с которого производится считывание, а правый операнд - объект, в который считываются данные.",
		"Для чтения с консоли применяется объект <b>cin</b>, который представляет тип istream. \n<code>#include &lt;iostream&lt; \nint main() \n{ \n    int age; \n    double weight; \n    std::cout &lt;&lt; 'Input age: '; \n    std::cin &gt;&gt; age; \n    std::cout &lt;&lt; 'Input weight: '; \n    std::cin &gt;&gt; weight; \n    std::cout &lt;&lt; 'Your age: ' &lt;&lt; age &lt;&lt; '\t your weight: ' &lt;&lt; weight &lt;&lt; std::endl; \n    return 0; \n}</code>",
		"Однако такой способ не очень подходит для чтения строк с консоли особенно когда считываемая строка содержит пробельные символы. В этом случае лучше использовать встроенную функцию <b>getline()</b>, которая в качестве параметра принимает поток istream и переменную типа string, в которую надо считать данные:",
		"<code>#include &lt;iostream&gt; \n#include &lt;string&gt; \nint main() \n{ \n    std::string name; \n    std::cout &lt;&lt: 'Input name: ';    getline(std::cin, name); \n    //std::cin &gt;&gt; name; \n    std::cout &lt;&lt; 'Your name: ' &lt;&lt; name &lt;&lt;std::endl; \n    return 0; \n}</code> \nКонсольный вывод данной программы:",
		"<b>Input name: Tom Smit</b> \n<b>Your name: Tom Smit</b> \n<b>Вывод ошибок</b> \nДля вывода сообщения об ошибке на консоль применяется объект <b>cerr</b>, который представляет объект типа ostream: \n<code>#include &lt;iostream&gt; \nint main() \n{ \n    std::cerr &lt;&lt; 'Error occured' &lt;&lt; std::endl; \n    return 0; \n}</code>",
		"<b>Потоки символов wchar_t</b> \nДля работы с потоками данных типов wchar_t в стандартной библиотеке определены объекты <b>wcout</b> (тип wostream), <b>wcerr</b> (тип wostream) и <b>wcin</b> (тип wistream), которые являются аналогами для объектов cout, cerr и cin и работают аналогично",
		"#include &lt;iostream&gt; \nint main() \n{ \n    int age; \n    double weight; \n    std::wcout &lt;&lt; 'Input age: '; \n    std::wcin &lt;&lt; age; \n    std::wcout &lt;&lt; 'Input weight: '; \n    std::wcin &gt;&gt; weight; \n    if (age &lt;= 0 || weight &lt;= 0) \n        std::wcerr &lt;&lt; 'Invalid data' &lt;&lt; std::endl;    else \n        std::wcout &lt;&lt; 'Your age: ' &lt;&lt; age &lt;&lt; '\t your weight: ' &lt;&lt; weight &lt;&lt; std::endl; \n    return 0; \n}</code>"
		]
	},
	
	"file_streams":
	{
	"name": "Файловые потоки",
	"page_1":
	[
	"Для работы с файлами в стандартной библиотеке определен заголовочный файл <b>fstream</b>, который определяет базовые типы для чтения и записи файлов. В частности, это: \n<b>ifstream</b>: для чтения с файла \n<b>ofstream</b>: для записи в файл \n<b>fstream</b>: совмещает запись и чтение \nДля работы с данными типа <b>wchar_t</b> для этих потоков определены двойники: <b>wifstream</b> \n<b>wofstream</b> \n<b>wfstream</b>",
	"<b>Открытие файла</b> \nПри операциях с файлом вначале необходимо открыть файл с помощью функции <b>open()</b>. Данная функция имеет две версии: \nopen(путь) \nopen(путь, режим) \nДля открытия файла в функцию необходимо передать путь к файлу в виде строки. И также можно указать режим открытия. Список доступных режимов открытия файла:",
	"<b>ios::in</b>: файл открывается для ввода (чтения). Может быть установлен только для объекта ifstream или fstream \n<b>ios::out</b>: файл открывается для вывода (записи). При этом старые данные удаляются. Может быть установлен только для объекта ofstream или fstream \n<b>ios::app</b>: файл открывается для дозаписи. Старые данные не удаляются.",
	"<b>ios::ate</b>: после открытия файла перемещает указатель в конец файла \n<b>ios::trunc</b>: файл усекается при открытии. Может быть установлен, если также установлен режим out \n<b>ios::binary</b>: файл открывается в бинарном режиме \nЕсли при открытии режим не указан, то по умолчанию для объектов ofstream применяется режим ios::out, а для объектов ifstream - режим ios::in. Для объектов fstream совмещаются режимы ios::out и ios::in.",
	"<code>std::ofstream out;          // поток для записи \nout.open('D:\\hello1.txt'); // окрываем файл для записи \nstd::ofstream out2; \nout2.open('D:\\hello2.txt', std::ios::app); // окрываем файл для дозаписи \nstd::ofstream out3; \nout2.open('D:\\hello3.txt', std::ios::out | std::ios::trunc); // установка нескольких режимов \nstd::ifstream in;       // поток для чтения \nin.open('D:\\hello4.txt'); // окрываем файл для чтения \nstd::fstream fs;        // поток для чтения-записи \nfs.open('D:\\hello5.txt'); // окрываем файл для чтения-записи"</code>,
	"Однако в принципе необязательно использовать функцию open для открытия файла. В качестве альтернативы можно также использовать конструктор объектов-потоков и передавать в них путь к файлу и режим открытия: \n<code>fstream(путь) \nfstream(путь, режим)</code> \nПри вызове конструктора, в который передан путь к файлу, данный файл будет автоматически открываться: \nstd::ofstream out('D:\\hello.txt'); \nstd::ifstream in('D:\\hello.txt'); \nstd::fstream fs('D:\\hello.txt', std::ios::app);</code>",
	"Вообще использование конструкторов для открытия потока является более предпочтительным, так как определение переменной, представляющей файловой поток, уже преполагает, что этот поток будет открыт для чтения или записи. А использование конструктора избавит от ситуации, когда мы забудем открыть поток, но при этом начнем его использовать.",
	"В процессе работы мы можем проверить, окрыт ли файл с помощью функции is_open(). Если файл открыт, то она возвращает true: \n<code>std::ifstream in;       // поток для чтения \nin.open('D:\\hello.txt'); // окрываем файл для чтения \n// если файл открыт \nif (in.is_open()) \n{ \n}</code>",
	"<b>Закрытие файла</b> \nПосле завершения работы с файлом его следует закрыть с помощью функции <b>close()</b>. Также стоит отметить, то при выходе объекта потока из области видимости, он удаляется, и у него автоматически вызывается функция close.",
	"<code>#include &lt;iostream&gt; \n#include &lt;fstream&gt; \nint main() \n{ \nstd::ofstream out;          // поток для записи \nout.open('D:\\hello.txt'); // окрываем файл для записи \nout.close();            // закрываем файл \nstd::ifstream in;       // поток для чтения \nin.open('D:\\hello.txt'); // окрываем файл для чтения \nin.close();             // закрываем файл \nstd::fstream fs;        // поток для чтения-записи \nfs.open('D:\\hello.txt'); // окрываем файл для чтения-записи \nfs.close();             // закрываем файл \nreturn 0; \n}</code>",
	"Стоит отметить, что при компиляции через <b>g++</b> следует использовать флаг <b>-static</b>, если программа работает со файлами и использует типы из заголовочного файла fstream: \n<b>g++ app.cpp -o app -static</b>"
	]
	}
}
