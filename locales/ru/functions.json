{
	"id": "functions",
	"name": "<b>Функции</b>",
	"overview": "В этом разделе объясняются концепции, которые имеют решающее значение для понимания <b>функций</b>.",

	"definition": {
		"name": "Определение",
		"page_1": [
			"<b>Определение функции</b> \nФункция определяет действия, которые выполняет программа. Функции позволяют выделить набор инструкций и придать ему имя. А затем многократно по присвоенному имени вызывать в различных частях программы. По сути функция - это именованный блок кода.",
			"Формальное определение функции выглядит следующим образом:\n<code>type function_name(parameters) \n{ \ninstructions \n}</code> \nПервая строка представляет заголовок функции. Вначале указывается возвращаемый тип функции. Если функция не возвращает никакого значения, то используется тип <b>void</b>.",
			"Затем идет имя функции, которое представляет произвольный идентификатор. К именованию функции применяются те же правила, что и к именованию переменных. \nTПосле имени функции в скобках идет перечисление параметров. Функция может не иметь параметров, в этом случае указываются пустые скобки.",
			"После заголовка функции в фигурных скобках идет тело функции, которое содержит выполняемые инструкции. \nДля возвращения результата функция применяет оператор <b>return</b>. Если функция имеет в качестве возвращаемого типа любой тип, кроме void, то она должна обязательно с помощью оператора return возвращать какое-либо значение.",
			"Например, определение функции main, которая должна быть в любой программе на языке C++ и с которой начинается ее выполнение: \nc<ode>int main() \n{ \nreturn 0; \n}</code> \nВозвращаемым типом функции является тип <b>int</b>, поэтому функция должна использовать оператор <b>return</b> и возвращать какое-либо значение, которое соответствует типу int. Возвращаемое значение ставится после оператора return.",
			"Но если функция имеет тип <b>void</b>, то ей не надо ничего возвращать. Например, мы могли бы определить следующую функцию: \n<code>void hello() \n{ \nstd::cout &lt;&lt; 'hello\n'; \n}</code>",
			"<b>Выполнение функции</b> \nДля выполнения функции ее необходимо вызвать. Вызов функции осуществляется в форме: \n<code>имя_функции(аргументы);</code> \nПосле имени функции указываются скобки, в которых перечисляются аргументы - значения для параметров функции.",
			"Например, определим и выполним простейшую функцию: \n<code>#include &lt;iostream&gt; \nvoid hello() \n{ \nstd::cout &lt;&lt; 'hello\n'; \n} \nint main() \n{ \nhello(); \nhello(); \nreturn 0; \n}</code>",
			"В этом случае перед вызовом функции надо ее дополнительно объявить. Объявление функции еще называют прототипом. Формальное объявление выглядит следующим образом: \n<code>тип имя_функции(параметры);;</code> \nФактически это заголовок функции. То есть для функции hello объявление будет выглядеть следующим образом:",
			"<code>void hello();</code> \nWe use the function declaration: \n<code>#include &lt;iostream&gt; \nvoid hello(); \nint main() \n{ \nhello(); \nhello(); \nreturn 0; \n} \nvoid hello() \n{ \nstd::cout &lt;&lt; 'hello\n'; \n}</code>",
			"В данном случае несмотря на то, что определение функции идет после ее вызова, но так как функция уже объявлена до ее вызова, то компилятор уже будет знать о функции hello, и никаких проблем в работе программы не возникнет."
		]
	},

	"function_parameters": {
		"name": "Параметры функции",
		"page_1": [
			"Через параметры в функцию можно передать различеые значения. Параметры перечисляются в скобках после имени функции имеют следующее определение: \n<code>тип название_параметра</code> \nНапример, определим программу обменного пункта:",
			"<code>#include &lt;iostream&gt; \nvoid exchange(double, double); \nint main() \n{ \ndouble rate = 58; \ndouble sum = 5000; \nexchange(rate, sum); \nexchange(60, 5000); \nreturn 0; \n} \nvoid exchange(double currate, double sum) \n{ \ndouble result = sum / currate; \nstd::cout &lt;&lt;  'Rate: ' &lt;&lt; currate &lt;&lt; '\tSum: ' &lt;&lt; sum &lt;&lt; '\tResult: ' &lt;&lt; result &lt;&lt; std::endl; \n}</code>",
			"При запуске программы мы получим следующий консольный вывод: \n<b>Rate: 58 \nSum: 5000 \nResult: 86.2069 \nRate: 60 \nSum: 5000 \nResult: 83.3333</b> \nФункция exchange принимает два параметра типа double, которые называются currate (текущий курс) и sum (сумма, которую надо обменять).",
			"При вызове функции exchange для этих параметров необходимо передать значения. Значения, передаваемые параметрам функции при ее вызове, называются аргументами. В данном случае в качестве аргументов передаются обычные числа. При этом аргументы передаются по позиции, то есть первый аргумент передается перому параметру, второй аргумент - второму параметру и так далее. При этом аргументы должны соответствовать параметрам по типу или допускать неявно преобразование в тип параметра.",
			"Рассмотрим еще один пример с функциями: \n<code>#include &lt;iostream&gt; \n#include &lt;string&gt; \nvoid square(int); \nvoid display(std::string, int); \nint main() \n{  \ndisplay('Tom', 33); \nsquare(4.56); \nreturn 0; \n} \nvoid square(int x) \n{ \nstd::cout &lt;&lt; 'Square of ' &lt;&lt; x &lt;&lt; ' is equal to ' &lt;&lt; x * x &lt;&Lt; std::endl; \n} \nvoid display(std::string name, int age) \n{ \nstd::cout &Lt;&lt; 'Name: ' &lt;&lt; name &lt;&lt; '\tAge: ' &Lt;&Lt; age &Lt;&Lt; std::endl; \n}</code>",
			"Функция display принимает параметры типов string и int. При вызове этой функции в нее вначале передается строка ('Tom'), так как параметр типа string идет первым, а потом число (33), так как параметр типа int идет вторым: display('Tom', 33)",
			"Функция square принимает число и выводит на консоль его квадрат. Параметр функции представляет тип int, однако при ее вызове ей передается число с плавающей точкой, то есть значение типа double. Поэтому производится преобразование от типа double к типу int, дробная часть отбрасывается, и в итоге функция получает число 4."
		],

		"page_2": [
			"<b>Аргументы по умолчанию</b> \nФункция может принимать аргументы по умолчанию, то есть некоторые значения, которые функция использует, если при вызове для параметров явным образом не передается значение:",
			"<code>#include &lt;iostream&gt; \nvoid multiply(int n, int m = 3) \n{ \nint result = n * m; \nstd::cout &lt;&lt; 'n * m = ' &lt;&lt; result &lt;&lt; std::endl; \n} \nint main() \n{ \nmultiply(4, 5); \nmultiply(4); \nreturn 0; \n}</code>",
			"Для установки значения по умолчанию параметру присваивается это значение int m = 3. И если для второго параметра не будет передано значение, то он будет использовать значение по умолчанию. Консольный вывод программы: \n<b>n * m = 20 \nn * m = 12",
			"При объявлении прототипа подобной функции он тоже может содержать значение по умолчанию для параметра. И в этом случае мы можем не определять в функции значение по умолчанию для параметра - оно будет браться из прототипа: \n<code>#include &lt;iostream&gt; \nvoid multiply(int n, int m=3); \nint main() \n{ \nmultiply(4, 5); \nmultiply(4); \nreturn 0; \n} \nvoid multiply(int n, int m) \n{ \nint result = n * m; \nstd::cout &lt;&lt; 'n * m = ' &lt;&lt; result &lt;&lt; std::endl; \n}</code>"
		]
	},
	
	"passing_arguments": 
	{
		
		"name": "Передача аргументов",
		"page_1":
		[
			"<b>Передача аргументов по значению</b> \nАргументы могут передаваться по значению (by value) и по ссылке (by reference). При передаче аргументов по значению внешний объект, который передается в качестве аргумента в функцию, не может быть изменен в этой функции. В функцию передается само значение этого объекта. Например:",
			"<code>#include &lt;iostream&gt; \nvoid square(int, int); \nint main() \n{ \nint a = 4; \nint b = 5; \nstd::cout &lt;&lt; 'Before square: a = ' &lt;&lt; a &lt;&lt; '\tb=' &lt;&lt; b &lt;&lt; std::endl; \nsquare(a, b); \nstd::cout &lt;&lt; 'After square: a = ' &lt;&lt; a &lt;&lt; '\tb=' &lt;&lt; b &lt;&lt; std::endl; \nreturn 0; \n} \nvoid square(int a, int b) \n{ \na = a * a; \nb = b * b; \nstd::cout &lt;&lt; 'In square: a = ' &lt;&lt; a &lt;&lt; '\tb=' &lt;&lt; b &lt;&lt; std::endl; \n}</code>",
			"Функция square принимает два числа и возводит их в квадрат. В функции main перед и после выполнения функции square происходит вывод на консоль значений переменных a и b, которые передаются в square в качестве аргументов. \nИ при выполнении мы увидим, что изменения аргументов в функции square действуют только в рамках этой функции. Вне ее значения переменных a и b остаются неизменными:",
			"<b>Before square: a = 4 	b = 5 \nIn square: a = 16		b = 25 \nAfter square: a = 4 	b = 5</b> \nПочему так происходит? При компиляции функции для ее параметров выделяются отдельные участки памяти. При вызове функции вычисляются значения аргументов, которые передаются на место параметров. И затем значения аргументов заносятся в эти участки памяти. То есть функция манипулирует копиями значений объектов, а не самими объектами.",
			"<b>Передача параметров по ссылке</b> \nПри передаче параметров по ссылке передается ссылка на объект, через которую мы можем манипулировать самим объектов, а не просто его значением. Так, перепишем предыдущий пример, используя передачу по ссылке:",
			"<code>#include &lt;iostream&gt; \nvoid square(int&, int&); \nint main() \n{ \nint a = 4; \nint b = 5; \nstd::cout &lt;&lt; 'Before square: a = ' &lt;&lt; a &lt;&lt; '\tb=' &lt;&lt; b &lt;&lt; std::endl; \nsquare(a, b); \nstd::cout &lt;&lt; 'After square: a = ' &lt;&lt; a &lt;&lt; '\tb=' &lt;&lt; b &lt;&lt; std::endl; \nreturn 0; \n} \nvoid square(int &a, int &b) \n{ \na = a * a; \nb = b * b; \nstd::cout &lt;&lt; 'In square: a = ' &lt;&lt; a &lt;&lt; '\tb=' &lt;&lt; b &lt;&lt; std::endl; \n}</code>",
			"Теперь параметры a и b передаются по ссылке. Ссылочный параметр связывается непосредственно с объектом, поэтому через ссылку можно менять сам объект. \nИ если мы скомпилируем и запустим программу, то результат будет иным: \nBefore square: a = 4 	b = 5 \nIn square: a = 16		b = 25 \nAfter square: a = 16 	b = 25",
			"Передача по ссылке позволяет возвратить из функции сразу несколько значений. Также передача параметров по ссылке является более эффективной при передаче очень больших объектов. Поскольку в этом случае не происходит копирования значений, а функция использует сам объект, а не его значение. \nОт передачи аргументов по ссылке следует отличать передачу ссылок в качестве аргументов:",
			"<code>#include &lt;iostream&gt; \nvoid square(int, int); \nint main() \n{ \nint a = 4; \nint b = 5; \nint &amp;aRef = a; \nint &amp;bRef = b; \nstd::cout &lt;&lt; 'Before square: a = ' &lt;&lt; a &lt;&lt; '\tb=' &lt;&lt; b &lt;&lt; std::endl; \nsquare(aRef, bRef); \nstd::cout &lt;&lt; 'After square: a = ' &lt;&lt; a &lt;&lt; '\tb=' &lt;&lt; b &lt;&lt; std::endl; \nreturn 0; \n} \nvoid square(int a, int b) \n{ \na = a * a; \nb = b * b; \nstd::cout &lt;&lt; 'In square: a = ' &lt;&lt; a &lt;&lt; '\tb=' &lt;&lt; b &lt;&lt; std::endl; \n}</code>",
			"Если функция принимает аргументы по значению, то изменение параметров внутри функции также никак не скажется на внешних объектах, даже если при вызове функции в нее передаются ссылки на объекты. \nBefore square: a = 4 	b = 5 \nIn square: a = 16		b = 25 \nAfter square: a = 4 	b = 5",
			"Передача параметров по значению больше подходит для передачи в функцию небольших объектов, значения которых копируются в определенные участки памяти, которые потом использует функция. \nПередача параметров по ссылке больше подходит для передачи в функцию больших объектов, в этом случае не нужно копировать все содержимое объекта в участок памяти, за счет чего увеличивается производительность программы."
		]
	},
	
	"const_parameters":
	{
		"name": "Константные параметры",
		"page_1":
		[
			"Параметры могут быть константными - значения таких параметров не могут меняться. Например: \n<code>void square(const int n) \n{ \n// n = n * n;  // можно считать значение параметра, но не изменять его \nstd::cout << n * n << std::endl; \n}</code> \nТо же самое касается и передачи параметра по ссылке: \n<code>void square(const int &n) \n{ \n// n = n * n;  // можно считать значение параметра, но не изменять его \nstd::cout << n << std::endl; \n}</code> \nКонстантному параметру можно передать в качестве аргумента как константу, так и переменную:",
			"<code>#include &lt;iostream&gt; \nvoid square(const int, const int); \nint main() \n{ \nconst int a = 4; \nint b = 5; \nsquare(a, b);   // 20 \nreturn 0; \n} \nvoid square(const int a, const int b) \n{ \n//a = a * a;     так нельзя сделать \n//b = b * b;     так нельзя сделать \nstd::cout &lt;&lt; 'In square: a * b = ' &lt;&lt; a * b &lt;&lt; std::endl; \n}</code> \nОт этой ситуации следует отличать передачу констант в качестве аргументов для неконстантных параметров:",
			"<code>#include &lt;iostream&gt; \nvoid square(int, int); \nint main() \n{ \nconst int a = 4; \nconst int b = 5; \nsquare(a, b);   // 400 \nreturn 0; \n} \nvoid square(int a, int b) \n{ \na = a * a; \nb = b * b; \nstd::cout &lt;&lt; 'In square: a * b = ' &lt;&lt; a * b &lt;&lt; std::endl; \n}</code> \nНесмотря на то, что при вызове функции ей передаются константы, но так как сами параметры не являются константными, то функция может изменять их значения.",
			"<b>Константные ссылки</b> \nЕсли функция получает аргументы по ссылке, то чтобы передать в функцию константу, параметры тоже должны представлять ссылку на константу: \n<code>#include &lt;iostream&gt; \nvoid square(const int&, const int&); \nint main() \n{ \nconst int a = 4; \nconst int b = 5; \nsquare(a, b);   // 20 \nreturn 0; \n} \nvoid square(const int &a, const int &b) \n{ \n// a = a * a;   так нельзя сделать \n// b = b * b;   так нельзя сделать \nstd::cout &lt;&lt; 'In square: a * b = ' &lt;&lt; a * b &lt;&lt; std::endl; \n}</code>",
			"И если в функцию необходимо передать большие объекты, которые не должны изменяться, то определение параметров именно как константных ссылок больше всего подходит для данной задачи."
		]
	},
	
	"return_statement":
	{
		"name": "Оператор return",
		"page_1":
		[
			"Для возвращения результата из функции применяется оператор <b>return</b>. Этот оператор имеет две формы: \nreturn; \nreturn выражение; \nПервая форма используется, если в качестве возвращаемого типа функции применяется тип <b>void</b>. Например:",
			"<code>#include &lt;iostream&gt; \nvoid factorial(int); \nint main() \n{ \nfactorial(-3); \nfactorial(5); \nfactorial(4); \nreturn 0; \n} \nvoid factorial(int n) \n{ \nif(n&glt;1) \n{ \nstd::cout &lt;&lt; 'Incorrect number' &lt;&lt; std::endl; \nreturn; \n} \nint result = 1; \nfor(int i = 1; i &lt;=n; i++) \n{ \nresult *= i; \n} \nstd::cout &lt;&lt; 'Factorial of ' &lt;&lt; n &lt;&lt; ' is equal to ' &lt;&lt; result &lt;&lt; std::endl; \n}</code>",
			"В данном случае функция factorial вычисляет факториал переданного числа. Однако если число меньше 1, то функция выводит соответствующее сообщение, и с помощью оператора return осуществляется выход из функции. \nВторая форма оператора return применяется для возвращения результата из функции. Если функция имеет в качестве возвращаемого типа любой тип, отличный от void, то такая функция обязятельно должна возвратить некоторое значение с помощью оператора return. Причем значение, которое возвращается оператором return, должно соответствовать возвращаемому типу функции, либо допускать неявное преобразование в этот тип.",
			"Например, возвратим из функции факториал числа: \n<code>#include &lt;iostream&gt; \nint factorial(int); \nint main() \n{ \nint n = 5; \nint result = factorial(n); \nstd::cout &lt;&lt; 'Factorial of ' &lt;&lt; n &lt;&lt; ' is equal to ' &lt;&lt; result &lt;&lt; std::endl; \nreturn 0; \n} \nint factorial(int n) \n{ \nint result = 1; \nfor(int i = 1; i &lt;=n; i++) \n{ \nresult *= i; \n} \nreturn result; \n}</code> \nТак как функция factorial возвращает значение, то ее результат можно присвоить какой-нибудь переменной или константе: \n<code>int result = factorial(n);</code>",
			"<b>Возвращение ссылки</b> \nНе следует возвращать ссылку на локальный объект, который создается внутри функции. Поскольку все создаваемые в функции объекты удаляеются после ее завершения, а их память очищается, то возвращаемая ссыла будет указывать на несуществующий объект, как в следующем случае: \n<code>int &factorial(int n) \n{ \nint result = 1; \nfor(int i = 1; i &lt;=n; i++) \n{ \nresult *= i; \n} \nreturn result; \n}</code>"
		]
	},
	
	"recursive_functions":
	{
		"name": "Рекурсивные функции",
		"page_1":
		[
			"Рекурсивные функции - это функции, которые вызывают сами себя. Например, определим вычисление факториала в виде рекурсивной функции: \n<code>#include &lt;iostream&gt; \nint factorial(int); \nint main() \n{ \nint n = 5; \nint result = factorial(n); \nstd::cout &lt;&lt; 'Factorial of ' &lt;&lt; n &lt;&lt; ' is equal to ' &lt;&lt; result &lt;&lt; std::endl; \nreturn 0; \n} \nint factorial(int n) \n{ \nif(n&gt;1) \nreturn n * factorial(n-1); \nreturn 1; \n}</code>",
			"В функции factorial задано условие, что если число n больше 1, то это число умножается на результат этой же функции, в которую в качестве параметра передается число n-1. То есть происходит рекурсивный спуск. И так далее, пока не дойдем того момента, когда значение параметра не будет равно 1. В этом случае функция возвратит 1. \nРекурсивная функция обязательно должна иметь некоторый базовый вариант, который использует оператор <b>return</b> и к которому сходится выполнение остальных вызовов этой функции. В случае с факториалом базовый вариант представлен ситуацией, при которой n = 1. В этом случае сработает инструкция return 1;.",
			"Например, при вызове factorial(5) получится следующая цепь вызовов: \n 1. 5 * factorial(4) \n2. 5 * 4 * factorial(3) \n3. 5 * 4 * 3 * factorial(2) \n4. 5 * 4 * 3 * 2 * factorial(1) \n5. 5 * 4 * 3 * 2 * 1 \nДругим распространенным показательным примером рекурсивной функции служит функция, вычисляющая числа Фиббоначчи. n-й член последовательности чисел Фибоначчи определяется по формуле: f(n)=f(n-1) + f(n-2), причем f(0)=0, а f(1)=1. Значения f(0)=0 и f(1)=1, таким образом, определяют базовые варианты для данной функции:",
			"<code>#include &lt;iostream&gt; \nint fibonachi(int); \nint main() \n{ \nint n; \nfor(int i = 0; i &lt; 10; i++) \n{ \n = fibonachi(i); \nstd::cout &lt;&lt; n &lt;&lt; '\t'; \n} \nstd::cout &lt;&lt; std::endl; \nreturn 0; \n} \nint fibonachi(int n) \n{ \nif (n == 0) \nreturn 0; \nif (n == 1) \nreturn 1; \nreturn fibonachi(n - 1) + fibonachi(n - 2); \n}</code> \nРезультат работы программы - вывод 10 чисел из последовательности Фиббоначчи на консоль: \n<b>0,   1,   1,   2,   3,   5,   8,   13,   21,   34</b>"
		]
	},
	
	"object_scope":
	{
		"name": "Область видимости объектов",
		"page_1":
		[
			"Область видимости (scope) представляет часть программы, в пределах которой можно использовать объект. Как правило, область видимости ограничивается блоком кода, который заключается в фигурные скобки В зависимости от области видимости создаваемые объекты могут быть глобальными, локальными или автоматическими. \n<b>Глобальные объекты</b> \nГлобальные переменные определены в файле программы вне любой из функций и могут использоваться любой функцией.",
			"<code>#include &lt;iostream&gt; \nvoid print(); \nint n = 5; \nint main() \n{ \nprint();                        // n=6 \nn++; \nstd::cout &lt;&lt; 'n=' &lt;&lt; n &lt;&lt; std::endl;   // n=7 \nreturn 0; \n} \nvoid print() \n{ \nn++ \nstd::cout &lt;&lt; 'n=' &lt;&lt; n &lt;&lt; std::endl; \n}</code> \nЗдесь переменная n является глобальной и доступна из любой функции. При этом любая функция может изменить ее значение.",
			"<b>Локальные объекты</b> \nОбъекты, которые создаются внутри блока кода (он может представлять функцию или какую-либо конструкцию типа циклов), называются локальными. Такие объекты доступны в пределах только того блока кода, в котором они определены. \n<b>Автоматические объекты</b> \nЛокальные объекты, которые существуют только во время выполнения того блока, в котором они определены, являются <b>автоматическими</b>. \nЛокальные объекты, которые существуют только во время выполнения того блока, в котором они определены, являются автоматическими.",
			"<code>#include &lt;iostream&gt; \nvoid print(int); \nint main() \n{ \nint z = 2; \nprint(z);               // n=10 \n//n++;      так сделать нельзя, так как n определена в функции print \nreturn 0; \n} \nvoid print(int x) \n{ \nint n = 5 * x; \n// z++; так сделать нельзя, так как z определена в функции main \nstd::cout &lt;&lt; 'n=' &lt;&lt; n &lt;&lt; std::endl; \n}</code>",
			"Здесь в функции print определена локальная переменная n. В функции main определена автоматическая переменная z. Вне своих функций эти переменные недоступны. Например, мы не можем использовать переменную n в функции main, так как ее область видимости ограничена функцией print. Соответственно также мы не можем использовать переменную z в функции print, так как эта переменная ограничена фукцией main. \nПараметры функции также, как и локальные переменные, существуют, пока выполняется функция, вне функции они не доступны. nПодобным образом с помощью блока кода можно определить вложенные области видимости:",
			"<code>#include &lt;iostream&gt; \nint main() \n{ \nint n = 2; \n{ \nint x = 5; \nstd::cout &lt;&lt; 'x=' &lt;&lt; x &lt;&lt; std::endl; \nn++;    // так можно, так как n определена во внешнем контексте \n} \n//x++;      // так сделать нельзя, так как x определена в блоке кода \nstd::cout &lt;&lt; 'n=' &lt;&lt; n &lt;&lt; std::endl; \nreturn 0; \n}</code>",
			"Для каждой области видимости доступны все те объекты, которые определены во внешней области видимости или во внешнем контексте. Глобальная область видимости является внешней для функции, поэтому функция может использовать глобальные переменные. А фукция является внешним контекстом для вложенного блока кода, поэтому блок кода может использовать переменную n, которая определена в функции вне этого блока. Однако переменные, определенные в блоке кода, вне этого блока использовать нельзя.",
			"<b>Сокрытие объектов</b> \nЛокальные объекты, определенные внутри одного контекста, могут скрывать объекты с тем же именем, определенные во внешнем контексте: \n<code>#include &lt;iostream&gt; \nint n = 5; \nint main() \n{ \nint n = 10; \nstd::cout &lt;&lt; 'n=' &lt;&lt; n &lt;&lt; std::endl;  // n=10 \n{ \nint n = 20; \nstd::cout &lt;&lt; 'n=' &lt;&lt; n &lt;&lt; std::endl; // n=20 \n} \nreturn 0; \n}</code> \nЗдесь определено три переменных с именем <b>n</b>. Переменная n, определенная на уровне функции main (int n = 10;) скрывает глобальную переменную n. А переменная n, определенная на уровне блока, скрывает переменную, определенную на уровне функции main."
		],
		
		"page_2":
		[
			"<b>Статические объекты</b> \nКроме автоматических есть особый тип локальных объектов - статические объекты. Они определяются на уровне функций с помощью ключевого слова <b>static</b>. Если автоматические переменные определяются и инициализируются при каждом входе в функцию, то статические переменные инициализируются только один раз, а при последующих вызовах функции используется старое значение статической переменной. \nНапример, пусть у нас будет функция со стандартной автоматической переменной:",
			"<code>#include &lt;iostream&gt; \nvoid display(); \nint main() \n{ \ndisplay(); \ndisplay(); \ndisplay(); \nreturn 0; \n} \nvoid display() \n{ \nint i = 0; \ni++; \nstd::cout &lt;&lt; 'i=' &lt;&lt; i &lt;&lt; std::endl; \n}</code> \nФункция display вызывается три раза, и при каждом вызове программа повторно будет выделять память для переменной i, которая определена в функции. А после завершения работы display, память для переменной i будет освобождаться. Соответственно ее значение при каждом вызове будет неизменно: \n<b>i=1</b> \n<b>i=1</b> \n<b>i=1</b> \nТеперь сделаем переменную i статической:",
			"<code>#include &lt;iostream&gt; \nvoid display(); \nint main() \n{ \ndisplay(); \ndisplay(); \ndisplay(); \nreturn 0; \n} \nvoid display() \n{ \nstatic int i = 0; \ni++; \nstd::cout &lt;&lt 'i=' &lt;&lt i &lt;&lt std::endl; // n=20 \n}</code> \nК переменной был добавлено ключевое слово static, поэтому при завершении работы функции display переменная не уничтожается, ее память не очищается, наоборот, она сохраняется в памяти. И соответственно результат работы программы будет иным: \n<b>i=1</b> \n<b>i=2</b> \n<b>i=3</b>"
		]
		
	},
}
