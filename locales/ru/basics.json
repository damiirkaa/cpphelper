{
	"id": "basics",
	"name": "<b>Базовые концепты</b>",
	"overview": "В этой секции разъясняются концепты, необходимыя для понимания языка <b>C++.</b>",

	"data_types": 
	{
		"name": "Типы данных",
		"page_1": 
		[
			"Каждая переменная имеет определенный тип. И этот тип определяет, какие значения может иметь переменная, какие операции с ней можно выполнять и сколько байтов в памяти она будет занимать. Следующие основные типы данных определены в <b>C++</b>:",
			"<b>bool:</b> логический тип. Может принимать одно из двух значений - _ True_ и _False_. Размер занимаемой памяти для этого типа точно не определен.",
			"<b>char:</b> представляет собой один символ ASCII. Он занимает в памяти 1 байт (8 бит). Может хранить любое значение от «-128» до «127» или от «0» до «255».",
			"<b>signed char:</b> представляет один символ. Он занимает в памяти 1 байт (8 бит). Может хранить любое значение от «-128» до «127».",
			"<b>unsigned char:</b> представляет один символ. Он занимает в памяти 1 байт (8 бит). Может хранить любое значение от «0» до «255».",
			"<b>wchar_t:</b> представляет собой широкий персонаж. В Windows он занимает в памяти 2 байта (16 бит), в Linux - 4 байта (32 бита). Может хранить любое значение от 0 до 65 535 (для 2 байтов) или от 0 до 4 294 967 295 (для 4 байтов).",
			"<b>char16_t:</b> представляет один символ Юникода. Он занимает в памяти 2 байта (16 бит). Может хранить любое значение от «0» до «65535»."

		],
		
		"page_2":
		[
			"<b>char32_t:</b> представляет один символ Юникода. Он занимает 4 байта (32 бита) в памяти. Может хранить любое значение от 0 до 4 294 967 295.",
			"<b>short:</b> представляет собой целое число в диапазоне от –32768 до 32767. Занимает 2 байта (16 бит) в памяти.",
			"<b>unsigned short:</b> представляет собой целое число в диапазоне от 0 до 65 535. Занимает 2 байта (16 бит) в памяти.",
			"<b>int:</b> представляет собой целое число. В зависимости от архитектуры процессора он может занимать 2 байта (16 бит) или 4 байта (32 бита). Диапазон предельных значений, соответственно, также может варьируются от -32768 до 32767 (для 2 байтов) или от -2 147 483 648 до 2 147 483 647 (для 4 байтов). Но в любом случае размер должен быть больше или равен размеру короткого типа и меньше или равен размер длинного типа. Этот тип является синонимом <b> signed int </b> и <b> signed </b>.",
			"<b>unsigned int:</b> представляет собой положительное целое число. Оно может занимать 2 байта (16 бит) или 4 байта (32 бита) в зависимости от архитектуры процессора, и поэтому диапазон предельных значений может варьируются: от 0 до 65535 (для 2 байтов) или от 0 до 4 294 967 295 (для 4 байтов). В качестве синонима этого типа может использоваться <b> беззнаковый </b>.",
			"<b>long:</b> представляет целое число от -2 147 483 648 до 2 147 483 647. Он занимает 4 байта (32 бита) памяти. Этот тип также имеет синонимы для <b> long int </b>, <b> подписанное длинное целое </b> и <b> длинное подписанное </b>."
			
		],
		
		"page_3":
		[
			"<b>unsigned long:</b> представляет собой целое число от 0 до 4 294 967 295. Занимает 4 байта (32 бита) памяти. Это синоним <b> unsigned long int </b>.",
			"<b>long long:</b> представляет собой целое число в диапазоне от -9 223 372 036 854 775 808 до +9 223 372 036 854 775 807. Обычно занимает 8 байтов (64 бита) памяти. Синонимы: < b> long long int </b>, <b> signed long long int </b> и <b> signed long long </b>. ",
			"<b>unsigned long long:</b> представляет собой целое число от 0 до 18 446 744 073 709 551 615. Обычно занимает 8 байтов (64 бита) памяти. Это синоним <b> unsigned long long int </b>.",
			"<b>float:</b> представляет собой вещественное число с плавающей запятой в диапазоне от +/- 3,4E-38 до 3,4E + 38. Занимает 4 байта (32 бита) в памяти.",
			"<b>double:</b> представляет действительное число с плавающей запятой двойной точности в диапазоне от +/- 1,7E-308 до 1,7E + 308. Оно занимает 8 байтов (64 бита) в памяти.",
			"<b>long double:</b> представляет действительное число с плавающей запятой двойной точности размером не менее 8 байтов (64 бита). Диапазон допустимых значений может отличаться в зависимости от размера занимаемой памяти.",
			"<b>void:</b> тип без значения.",
			"Таким образом, все типы данных, кроме void, можно разделить на три группы: символьные (char, wchar_t, char16_t, char32_t), целые (short, int, long, long long) и типы чисел с плавающей запятой (float, double, long double )."
		],
		
		"page_4":
		[
			"<b>Символьные типы</b>",
			"Для представления символов в приложении используются типы char, wchar_t, char16_t и char32_t. Определим несколько переменных: \n 1. <code>char c = d;</code> \n 2. <code>wchar_t d = c;</code> \n",
			"Переменная типа char в качестве значения принимает один символ в одинарных кавычках: char c ='d'. Также можно присвоить число из указанного выше в списке диапазона: char c = 120. В этом случае значением переменной c будет тот символ, который имеет код 120 в таблице символов ASCII.",
			"Стоит учитывать, что для вывода на консоль символов wchar_t следует использовать не std::cout, а поток <b>std::wcout</b>",
			"1. #include <iostream> \n 2. int main() \n 3. { /n 4. char a = 'H'; \n 5. wchar_t b ='e'; \n 6. std::wcout<<a<<b<<'/n'; \n 7. return 0; \n 8. }",
			"При этом поток std::wcout может работать как с char, так и с wchar_t. А поток std::cout для переменной wchar_t вместо символа будет выводить его числовой код.",
			"В стандарте С++11 были добавлены типы <b>char16_t</b> и <b>char32_t</b>, которые ориентированы на использование Unicode. Однако на уровне ОС пока не реализованы потоки для работы с этими типами. Поэтому если потребуется вывести на консоль значения переменных этих типов, то необходимо преобразовать переменные к типам char или wchar_t:",
			"1. #include <iostream> \n 2. int main() \n 3. { /n 4. char a = 'H'; \n 5. wchar_t b = 'e'; \n 6. char16_t c = 'l'; \n 7. char32_t d = 'o'; \n 8. std::cout<<a<<(char)b<<(char)c<<(char)d<<'/n'; \n 9. return 0; \n 10. }",
			"В данном случае при выводе перед переменными указывается операция приведения к типу char - <b>(char)</b>, благодаря чему значения переменных b, c и d преобразуются в тип char и могут быть выведены на консоль с помощью потока std::cout."
		],
		
		"page_5":
		[
			"<b>Целочисленные типы</b>;",
			"Целочисленные типы представлены следующими типами: <b>short, unsigned short, int, unsigned int, long, unsigned long, long long and unsigned long long:</b>",
			"1. <b>short</b> a = -10; \n 2. unsigned <b>short</b> b = 10; \n 3. <b>int</b> c = -30; \n 4. unsigned <b>int</b> d = 60; \n 5. <b>long</b> e = -170; \n 6. unsigned <b>long</b> f = 45; \n 7. <b>long long</b> g = 89;"
		],
		
		"page_6":
		[
			"<b>Типы чисел с плавающей точкой</b>",
			"Типы чисел с плавающей точкой или дробные числа представлены такими типами как <b>float, double</b>, и <b>long double:</b>",
			"1. <b>float</b> a = -10.45; \n 2. <b>double</b> b = 0.00105; \n 3. <b>long double</b> c = 30.890045;"
		],
		
		"page_7":
		[
			"<b>Размеры типов данных</b>",
			"В выше приведенном списке для каждого типа указан размер, который он занимает в памяти. Однако стоит отметить, что предельные размеры для типов разработчики компиляторов могут выбирать самостоятельно, исходя из аппаратных возможностей компьютера. Стандарт устанавливает лишь минимальные значения, которые должны быть. Например, для типов int и short минимальное значение - 16 бит, для типа long - 32 бита, для типа long double. При этом размер типа long должен быть не меньше размера типа int, а размер типа int - не меньше размера типа short, а размер типа long double должен быть больше double. К примеру, компилятор g++ под Windows для long double использует 12 байт, а компилятор, встроенный в Visual Studio и также работающий под Windows, для long double использует 8 байт. То есть даже в рамках одной платформы разные компиляторы могут по разному подходить к размерам некоторых типов данных. Но в целом используются те размеры, которые указаны выше при описании типов данных.",
			"Однако бывают ситуации, когда необходимо точно знать размер определенного типа. И для этого в С++ есть оператор <b>sizeof()</b>, который возвращает размер памяти в байтах, которую занимает переменная:",
			"1. #include <iostream> \n 2. int main() \n 3. { \n 4. <b>long double</b> number = 2; \n 5. std::cout<<'sizeof(number)='<<sizeof(number); \n 6. return 0; \n 7. }",
			"Консольный вывод при компиляции в g++:",
			"<b>sizeof(number) = 12</b>",
			"При этом при определении переменных важно понимать, что значение переменной не должно выходить за те пределы, которые очерчены для ее типа. Например:",
			"1. unsigned <b>short</b> number = -65535;",
			"Компиляция такого кода может пройти без ошибок, хотя некоторые компиляторы, как G++ могут выдавать предупреждения о том, что значение будет усечено. Однако при комиляции переменная number получит значение 1 - результат преобразования числа -65535 к типу unsigned short. То есть опять же результат будет не совсем тот, который ожидается. Значение переменной - это всего лишь набор битов в памяти, которые интерпретируются в соответствии с определенным типом. И для разных типов один и тот же набор битов может интерпретироваться по разному. Поэтому важно учитывать диапазоны значений для того или иного типа при присвоении переменной значения."
		],
		
		"page_8":
		[
			"<b>Спецификатор auto</b>",
			"Иногда бывает трудно определить тип выражения. И согласно последним стандартам можно предоставить компилятору самому выводить тип объекта. И для этого применяется спецификатор auto. При этом если мы определяем переменную со спецификатором <b>auto</b>, эта переменная должна быть обязательно инициализирована каким-либо значением:",
			"1. auto number = 5;",
			"На основании присвоенного значения компилятор выведет тип переменной. Неинициализированные переменные со спецификатором auto не допускаются:",
			"1. auto number;"
		]
	},
	
	"variables": 
	{
		"name": "Переменные",
		"page_1":
		[
			"Как и во многих языках программирования, в C++ для хранения данных используются <b>переменные</b>. Переменная имеет тип, имя и значение. Тип определяет, какую информацию может хранить переменная.",
			"Перед использованием любую переменную надо определить. Синтаксис определения переменной выглядит следующим образом:",
			"1. тип_переменной имя_переменной;",
			"Простейшее определение переменной: \n 1. int age; \n ",
			"Здесь определена переменная age, которая имеет тип <b>int</b>. Поскольку определение переменной представляет собой инструкцию, то после него ставится точка с запятой.",
			"Также стоит учитывать, что C++ - регистрозависимый язык, а это значит, что регистр символов имеет большое значение. То есть в следующем коде будут определяться две разные переменные:",
			"1. int age;",
			"2. int age;",
			"Подобное определение вызовет ошибку на этапе компиляции.",
			"И в довершеие следует сказать, что переменным стоит давать осмысленные имена, которые будут говорить об их предназначении."
		],
		
		"page_2":
		[
			"<b>Инициализация</b>",
			"После определения переменной можно присвоить некоторое значение:",
			"1. int age;",
			"2. age = 20;",
			"Например, определим в прогамме переменную и выведем ее значение на консоль: \n 1. #include <iostream> \n 2. int main() \n 3. { \n 4. int age; \n 5. age=28; \n 6. std::cout<<'Age='<<age; \n 7. return 0; \n 8. }",
			"С помощью последовательности операторов <b><<</b> можно вывести несколько значений на консоль.",
			"После компиляции и запуска скомпилированной программы на консоль будет выведено число 28.",
			"Однако также можно сразу при определении переменной дать ей некоторое начальное значение. Данный прием называется <b>инициализацией</b>, то есть присвоение переменной начального значения:",
			"1. #include <iostream> \n 2. int main() \n 3. { \n 4. int age = 28; \n 5. std::cout<<'Age ='<<age; \n 6. return 0; \n 7. }"
		],
		
		"page_3":
		[
			"<b>Инициализация по умолчанию</b>",
			"Если переменную не инициализировать, то происходит ее инициализация по умолчанию. И переменная получает некоторое значение по умолчанию, которое зависит от места, где эта переменная определена.",
			"Если переменная, которая представляет встроенный тип (например, тип int), определена внутри функции, то она получает неопределенное значение. Если переменная встроенного типа определена вне функции, то она получает то значение по умолчанию, которое соответствует ее типу. Для числовых типов это число 0. Например:",
			"1. #include <iostream> \n 2. int x; \n 3. int main() \n 4. { \n 5. int y; \n 6. std::cout<<'X='<<x<<'\n'; \n 7. std::cout<<'Y='<<y; \n 8. return 0; \n 9. }",
			"Переменная x определена вне функции, и поэтому она получит значение по умолчанию - число 0.",
			"Гораздо сложнее дело обстоит с переменной y, которая определена внутри функции main - ее значение будет неопределенным, и многое будет зависеть от используемого компилятора. В частности, вывод программы, скомпилированной с помощью компилятора G++, может выглядеть следующим образом:",
			"<b>x=0</b> \n <b>y=4200475</b>",
			"А в Visual Studio отсутствие значения переменной y вызовет ошибку.",
			"Но в любом случае перед использованием переменной лучше явным образом назначать ей определенное значение, а не полагаться на значение по умолчанию."
		],
		
		"page_4":
		[
			"<b>Изменение значения</b>",
			"Ключевой особенностью переменных является то, что мы можем изменять их значения:",
			"1. #include <iostream> \n 2. int main() \n 3. { \n 4. int x = 6; \n 5. x = 8; \n 6. x = 10; \n 7. std::cout<<'X='<<x; // X=10 \n 8. return 0; \n 9. }"
		]
	},
	"arithmetical_operations": 
	{
		"name": "Арифметические операции"
	},
	"static_typization": 
	{
		"name": "Статическая типизация"
	},
	"constants": 
	{
		"name": "Константы"
	},
	"console_io": 
	{
		"name": "Ввод/вывод в консоли"
	},
	"namespaces": 
	{
		"name": "Пространства имён"
	},
	"bit_operations": 
	{
		"name": "Побитовые операции"
	},
	"logical_operations": 
	{
		"name": "Логические операции"
	},
	"conditional_constructions": 
	{
		"name": "Условные конструкции"
	},
	"loops": 
	{
		"name": "Циклы"
	},
	"links": 
	{
		"name": "Ссылки"
	},
	"arrays": 
	{
		"name": "Массивы"
	},
	"strings": 
	{
		"name": "Строки"
	}
}
