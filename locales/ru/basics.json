{
	"id": "basics",
	"name": "<b>Базовые концепты</b>",
	"overview": "В этой секции разъясняются концепты, необходимыя для понимания языка <b>C++.</b>",

	"data_types": 
	{
		"name": "Типы данных",
		"page_1": 
		[
			"Каждая переменная имеет определенный тип. И этот тип определяет, какие значения может иметь переменная, какие операции с ней можно выполнять и сколько байтов в памяти она будет занимать. Следующие основные типы данных определены в <b>C++</b>:",
			"<b>bool:</b> логический тип. Может принимать одно из двух значений - _ True_ и _False_. Размер занимаемой памяти для этого типа точно не определен.",
			"<b>char:</b> представляет собой один символ ASCII. Он занимает в памяти 1 байт (8 бит). Может хранить любое значение от «-128» до «127» или от «0» до «255».",
			"<b>signed char:</b> представляет один символ. Он занимает в памяти 1 байт (8 бит). Может хранить любое значение от «-128» до «127».",
			"<b>unsigned char:</b> представляет один символ. Он занимает в памяти 1 байт (8 бит). Может хранить любое значение от «0» до «255».",
			"<b>wchar_t:</b> представляет собой широкий персонаж. В Windows он занимает в памяти 2 байта (16 бит), в Linux - 4 байта (32 бита). Может хранить любое значение от 0 до 65 535 (для 2 байтов) или от 0 до 4 294 967 295 (для 4 байтов).",
			"<b>char16_t:</b> представляет один символ Юникода. Он занимает в памяти 2 байта (16 бит). Может хранить любое значение от «0» до «65535»."

		],
		
		"page_2":
		[
			"<b>char32_t:</b> представляет один символ Юникода. Он занимает 4 байта (32 бита) в памяти. Может хранить любое значение от 0 до 4 294 967 295.",
			"<b>short:</b> представляет собой целое число в диапазоне от –32768 до 32767. Занимает 2 байта (16 бит) в памяти.",
			"<b>unsigned short:</b> представляет собой целое число в диапазоне от 0 до 65 535. Занимает 2 байта (16 бит) в памяти.",
			"<b>int:</b> представляет собой целое число. В зависимости от архитектуры процессора он может занимать 2 байта (16 бит) или 4 байта (32 бита). Диапазон предельных значений, соответственно, также может варьируются от -32768 до 32767 (для 2 байтов) или от -2 147 483 648 до 2 147 483 647 (для 4 байтов). Но в любом случае размер должен быть больше или равен размеру короткого типа и меньше или равен размер длинного типа. Этот тип является синонимом <b> signed int </b> и <b> signed </b>.",
			"<b>unsigned int:</b> представляет собой положительное целое число. Оно может занимать 2 байта (16 бит) или 4 байта (32 бита) в зависимости от архитектуры процессора, и поэтому диапазон предельных значений может варьируются: от 0 до 65535 (для 2 байтов) или от 0 до 4 294 967 295 (для 4 байтов). В качестве синонима этого типа может использоваться <b> беззнаковый </b>.",
			"<b>long:</b> представляет целое число от -2 147 483 648 до 2 147 483 647. Он занимает 4 байта (32 бита) памяти. Этот тип также имеет синонимы для <b> long int </b>, <b> подписанное длинное целое </b> и <b> длинное подписанное </b>."
			
		],
		
		"page_3":
		[
			"<b>unsigned long:</b> представляет собой целое число от 0 до 4 294 967 295. Занимает 4 байта (32 бита) памяти. Это синоним <b> unsigned long int </b>.",
			"<b>long long:</b> представляет собой целое число в диапазоне от -9 223 372 036 854 775 808 до +9 223 372 036 854 775 807. Обычно занимает 8 байтов (64 бита) памяти. Синонимы: < b> long long int </b>, <b> signed long long int </b> и <b> signed long long </b>. ",
			"<b>unsigned long long:</b> представляет собой целое число от 0 до 18 446 744 073 709 551 615. Обычно занимает 8 байтов (64 бита) памяти. Это синоним <b> unsigned long long int </b>.",
			"<b>float:</b> представляет собой вещественное число с плавающей запятой в диапазоне от +/- 3,4E-38 до 3,4E + 38. Занимает 4 байта (32 бита) в памяти.",
			"<b>double:</b> представляет действительное число с плавающей запятой двойной точности в диапазоне от +/- 1,7E-308 до 1,7E + 308. Оно занимает 8 байтов (64 бита) в памяти.",
			"<b>long double:</b> представляет действительное число с плавающей запятой двойной точности размером не менее 8 байтов (64 бита). Диапазон допустимых значений может отличаться в зависимости от размера занимаемой памяти.",
			"<b>void:</b> тип без значения.",
			"Таким образом, все типы данных, кроме void, можно разделить на три группы: символьные (char, wchar_t, char16_t, char32_t), целые (short, int, long, long long) и типы чисел с плавающей запятой (float, double, long double )."
		],
		
		"page_4":
		[
			"<b>Символьные типы</b>",
			"Для представления символов в приложении используются типы char, wchar_t, char16_t и char32_t. Определим несколько переменных: \n 1. <code>char c = d;</code> \n 2. <code>wchar_t d = c;</code> \n",
			"Переменная типа char в качестве значения принимает один символ в одинарных кавычках: char c ='d'. Также можно присвоить число из указанного выше в списке диапазона: char c = 120. В этом случае значением переменной c будет тот символ, который имеет код 120 в таблице символов ASCII.",
			"Стоит учитывать, что для вывода на консоль символов wchar_t следует использовать не std::cout, а поток <b>std::wcout</b>",
			"1. #include &lt;iostream&gt; \n 2. int main() \n 3. { /n 4. char a = 'H'; \n 5. wchar_t b ='e'; \n 6. std::wcout&lt;&lt;a&lt;&lt;b&lt;&lt;'/n'; \n 7. return 0; \n 8. }",
			"При этом поток std::wcout может работать как с char, так и с wchar_t. А поток std::cout для переменной wchar_t вместо символа будет выводить его числовой код.",
			"В стандарте С++11 были добавлены типы <b>char16_t</b> и <b>char32_t</b>, которые ориентированы на использование Unicode. Однако на уровне ОС пока не реализованы потоки для работы с этими типами. Поэтому если потребуется вывести на консоль значения переменных этих типов, то необходимо преобразовать переменные к типам char или wchar_t:",
			"1. #include &lt;iostream&gt; \n 2. int main() \n 3. { /n 4. char a = 'H'; \n 5. wchar_t b = 'e'; \n 6. char16_t c = 'l'; \n 7. char32_t d = 'o'; \n 8. std::cout&lt;&lt;a&lt;&lt;(char)b&lt;&lt;(char)c&lt;&lt;(char)d&lt;&lt;'/n'; \n 9. return 0; \n 10. }",
			"В данном случае при выводе перед переменными указывается операция приведения к типу char - <b>(char)</b>, благодаря чему значения переменных b, c и d преобразуются в тип char и могут быть выведены на консоль с помощью потока std::cout."
		],
		
		"page_5":
		[
			"<b>Целочисленные типы</b>;",
			"Целочисленные типы представлены следующими типами: <b>short, unsigned short, int, unsigned int, long, unsigned long, long long and unsigned long long:</b>",
			"1. <b>short</b> a = -10; \n 2. unsigned <b>short</b> b = 10; \n 3. <b>int</b> c = -30; \n 4. unsigned <b>int</b> d = 60; \n 5. <b>long</b> e = -170; \n 6. unsigned <b>long</b> f = 45; \n 7. <b>long long</b> g = 89;"
		],
		
		"page_6":
		[
			"<b>Типы чисел с плавающей точкой</b>",
			"Типы чисел с плавающей точкой или дробные числа представлены такими типами как <b>float, double</b>, и <b>long double:</b>",
			"1. <b>float</b> a = -10.45; \n 2. <b>double</b> b = 0.00105; \n 3. <b>long double</b> c = 30.890045;"
		],
		
		"page_7":
		[
			"<b>Размеры типов данных</b>",
			"В выше приведенном списке для каждого типа указан размер, который он занимает в памяти. Однако стоит отметить, что предельные размеры для типов разработчики компиляторов могут выбирать самостоятельно, исходя из аппаратных возможностей компьютера. Стандарт устанавливает лишь минимальные значения, которые должны быть. Например, для типов int и short минимальное значение - 16 бит, для типа long - 32 бита, для типа long double. При этом размер типа long должен быть не меньше размера типа int, а размер типа int - не меньше размера типа short, а размер типа long double должен быть больше double. К примеру, компилятор g++ под Windows для long double использует 12 байт, а компилятор, встроенный в Visual Studio и также работающий под Windows, для long double использует 8 байт. То есть даже в рамках одной платформы разные компиляторы могут по разному подходить к размерам некоторых типов данных. Но в целом используются те размеры, которые указаны выше при описании типов данных.",
			"Однако бывают ситуации, когда необходимо точно знать размер определенного типа. И для этого в С++ есть оператор <b>sizeof()</b>, который возвращает размер памяти в байтах, которую занимает переменная:",
			"1. #include &lt;iostream&gt; \n 2. int main() \n 3. { \n 4. <b>long double</b> number = 2; \n 5. std::cout&lt;&lt;'sizeof(number)='&lt;&lt;sizeof(number); \n 6. return 0; \n 7. }",
			"Консольный вывод при компиляции в g++:",
			"<b>sizeof(number) = 12</b>",
			"При этом при определении переменных важно понимать, что значение переменной не должно выходить за те пределы, которые очерчены для ее типа. Например:",
			"1. unsigned <b>short</b> number = -65535;",
			"Компиляция такого кода может пройти без ошибок, хотя некоторые компиляторы, как G++ могут выдавать предупреждения о том, что значение будет усечено. Однако при комиляции переменная number получит значение 1 - результат преобразования числа -65535 к типу unsigned short. То есть опять же результат будет не совсем тот, который ожидается. Значение переменной - это всего лишь набор битов в памяти, которые интерпретируются в соответствии с определенным типом. И для разных типов один и тот же набор битов может интерпретироваться по разному. Поэтому важно учитывать диапазоны значений для того или иного типа при присвоении переменной значения."
		],
		
		"page_8":
		[
			"<b>Спецификатор auto</b>",
			"Иногда бывает трудно определить тип выражения. И согласно последним стандартам можно предоставить компилятору самому выводить тип объекта. И для этого применяется спецификатор auto. При этом если мы определяем переменную со спецификатором <b>auto</b>, эта переменная должна быть обязательно инициализирована каким-либо значением:",
			"1. auto number = 5;",
			"На основании присвоенного значения компилятор выведет тип переменной. Неинициализированные переменные со спецификатором auto не допускаются:",
			"1. auto number;"
		]
	},
	
	"variables": 
	{
		"name": "Переменные",
		"page_1":
		[
			"Как и во многих языках программирования, в C++ для хранения данных используются <b>переменные</b>. Переменная имеет тип, имя и значение. Тип определяет, какую информацию может хранить переменная.",
			"Перед использованием любую переменную надо определить. Синтаксис определения переменной выглядит следующим образом:",
			"1. тип_переменной имя_переменной;",
			"Простейшее определение переменной: \n 1. int age; \n ",
			"Здесь определена переменная age, которая имеет тип <b>int</b>. Поскольку определение переменной представляет собой инструкцию, то после него ставится точка с запятой.",
			"Также стоит учитывать, что C++ - регистрозависимый язык, а это значит, что регистр символов имеет большое значение. То есть в следующем коде будут определяться две разные переменные:",
			"1. int age;",
			"2. int age;",
			"Подобное определение вызовет ошибку на этапе компиляции.",
			"И в довершеие следует сказать, что переменным стоит давать осмысленные имена, которые будут говорить об их предназначении."
		],
		
		"page_2":
		[
			"<b>Инициализация</b>",
			"После определения переменной можно присвоить некоторое значение:",
			"1. int age;",
			"2. age = 20;",
			"Например, определим в прогамме переменную и выведем ее значение на консоль: \n 1. #include &lt;iostream&gt; \n 2. int main() \n 3. { \n 4. int age; \n 5. age=28; \n 6. std::cout&lt;&lt;'Age='&lt;&lt;age; \n 7. return 0; \n 8. }",
			"С помощью последовательности операторов <b>&lt;&lt;</b> можно вывести несколько значений на консоль.",
			"После компиляции и запуска скомпилированной программы на консоль будет выведено число 28.",
			"Однако также можно сразу при определении переменной дать ей некоторое начальное значение. Данный прием называется <b>инициализацией</b>, то есть присвоение переменной начального значения:",
			"1. #include &lt;iostream&gt; \n 2. int main() \n 3. { \n 4. int age = 28; \n 5. std::cout&lt;&lt;'Age ='&lt;&lt;age; \n 6. return 0; \n 7. }"
		],
		
		"page_3":
		[
			"<b>Инициализация по умолчанию</b>",
			"Если переменную не инициализировать, то происходит ее инициализация по умолчанию. И переменная получает некоторое значение по умолчанию, которое зависит от места, где эта переменная определена.",
			"Если переменная, которая представляет встроенный тип (например, тип int), определена внутри функции, то она получает неопределенное значение. Если переменная встроенного типа определена вне функции, то она получает то значение по умолчанию, которое соответствует ее типу. Для числовых типов это число 0. Например:",
			"1. #include &lt;iostream&gt; \n 2. int x; \n 3. int main() \n 4. { \n 5. int y; \n 6. std::cout&lt;&lt;'X='&lt;&lt;x&lt;&lt;'\n'; \n 7. std::cout&lt;&lt;'Y='&lt;&lt;y; \n 8. return 0; \n 9. }",
			"Переменная x определена вне функции, и поэтому она получит значение по умолчанию - число 0.",
			"Гораздо сложнее дело обстоит с переменной y, которая определена внутри функции main - ее значение будет неопределенным, и многое будет зависеть от используемого компилятора. В частности, вывод программы, скомпилированной с помощью компилятора G++, может выглядеть следующим образом:",
			"<b>x=0</b> \n <b>y=4200475</b>",
			"А в Visual Studio отсутствие значения переменной y вызовет ошибку.",
			"Но в любом случае перед использованием переменной лучше явным образом назначать ей определенное значение, а не полагаться на значение по умолчанию."
		],
		
		"page_4":
		[
			"<b>Изменение значения</b>",
			"Ключевой особенностью переменных является то, что мы можем изменять их значения:",
			"1. #include &lt;iostream&gt; \n 2. int main() \n 3. { \n 4. int x = 6; \n 5. x = 8; \n 6. x = 10; \n 7. std::cout&lt;&lt;'X='&lt;&lt;x; // X=10 \n 8. return 0; \n 9. }"
		]
	},
	"arithmetical_operations": 
	{
		"name": "<b>Арифметические операции</b>",
		"page_1":
		[
			"Арифметические операции производятся над числами. Значения, которые участвуют в операции, называются операндами. В языке программирования C++ арифметические операции бинарными (производятся над двумя операндами) и унарными (выполняются над одним операндом). К бинарным операциям относят следующие:",
			"<b>+</b>",
			"Операция сложения возвращает сумму двух чисел: \nint a = 10; \nint b = 7; \nint c = a + b; //17 \nint d = 4 + b; //11",
			"<b>-</b>",
			"Операция вычитания возвращает разность двух чисел: \nint a = 10; \nint b = 7; \nint c = a - b; //3 \nint d = 41 - b; //34",
			"<b>*</b>",
			"Операция умножения возвращает произведение двух чисел: \nint a = 10; \nint b = 7; \nint c = a * b; //70 \nint d = b * 5; //35",
			"<b>/</b>",
			"Операция деления возвращает частное двух чисел: \nint a = 20; \nint b = 5; \nint c = a / b; //4 \ndouble d = 22.5 * 4.5; //5 \nПри делении стоит быть внимательным, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа, даже если результат присваивается переменной float или double:",
			"<b>double</b> k = 10 / 4; //2 \nstd::cout&lt;&lt;k; \nЧтобы результат представлял числос плавающей точкой, один из операндов также должен представлять число с плавающей точкой: \n<b>double</b> k = 10.0 / 4 //2.5 \nstd::cout&lt;&lt;k;",
			"<b>%</b>",
			"Операция получения остатка от целочисленного деления: \nint a = 33; \nint b = 5; \nint c = a % b; //3 \nint d = 22 % 4 //2 (22-4*5=2)",
			"Также есть две унарные арифметические операции, которые производятся над одним числом: ++ (инкремент) и -- (декремент). Каждая из операций имеет две разновидности: префиксная и постфиксная:"
		],
		
		"page_2":
		[
			"<b>Префиксный инкремент</b>",
			"Увеличивает значение переменной на единицу и полученный результат используется как значение выражения ++x \nint a = 8; \nint b = ++a; \nstd::cout&lt;&lt;a,<'\n'; //9 \nstd::cout&lt;&lt;b&lt;&lt;'\n'; //9",
			"<b>Постфиксный инкремент</b>",
			"Увеличивает значение переменной на единицу, но значением выражения x++ будет то, которое было до увеличения на единицу --x \nint a = 8; \nint b = a++; \nstd::cout&lt;&lt;a,<'\n'; //9 \nstd::cout&lt;&lt;b&lt;&lt;'\n'; //8",
			"<b>Префиксный декремент</b>",
			"Уменьшает значение переменной на единицу, и полученное значение используется как значение выражения --x \nint a = 8; \nint b = --a; \nstd::cout&lt;&lt;a,<'\n'; //7 \nstd::cout&lt;&lt;b&lt;&lt;'\n'; //7",
			"<b>Постфиксный декремент.</b>",
			"Уменьшает значение переменной на единицу, но значением выражения x-- будет то, которое было до уменьшения на единицу \nint a = 8; \nint b = a--; \nstd::cout&lt;&lt;a,<'\n'; //7 \nstd::cout&lt;&lt;b&lt;&lt;'\n'; //8",
			"Арифметические операции вычисляются слева направо. Одни операции имеют больший приоритет чем другие и поэтому выполняются вначале. Операции в порядке уменьшения приоритета:\n+ (инкремент), - (декремент) \n* (умножение), / (деление), % (остаток от деления) \n+ (сложение), - (вычитание)",
			"Приоритет операций следует учитывать при выполнении набора арифметических выражений: \nint a = 8; \nint b = 7; \nint c = a + 5 * ++b; //48 \nstd::cout&lt;&lt;c; \nХотя операции выполняются слева направо, но вначале будет выполняться операция инкремента ++b, которая увеличит значение переменной b и возвратит его в качестве результата, так как эта операция имеет больший приоритет. Затем выполняется умножение 5 * ++b, и только в последнюю очередь выполняется сложение a + 5 * ++b",
			"Скобки позволяют переопределить порядок вычислений. Например: \nint a = 8; \nint b = 7; \nint c = (a + 5) * ++b; //104 \nstd::cout&lt;&lt;c; \nНесмотря на то, что операция сложения имеет меньший приоритет, но вначале будет выполняться именно сложение, а не умножение, так как операция сложения заключена в скобки."
		]
		
	
	},
	
	"static_typization": 
	{
		"name": "Статическая типизация",
		"page_1":
		[
			"С++ является статически типизированным языком программирования. То есть если мы определили для переменной какой-то тип данных, то в последующем мы этот тип изменить не сможем. Соответственно переменная может получить значения только того типа, который она представляет. Однако нередко возникает необходимость присвоить переменной значения каких-то других типов. И в этом случае применяются преобразования типов.",
			"Ряд преобразований компилятор может производить неявно, то есть автоматически. Например:",
			"1. #include &lt;iostream&gt; \nint main() \n{ \nint code = 'g'; \nchar letter = 103; \nstd::cout&lt;&lt;letter&lt;&lt;'in ASCII is'&lt;&lt;code&lt;&lt;'\n'; \nreturn 0; \n}",
			"В данном случае числовой переменной типа int присваивается символ 'g'. Этот символ будет автоматически преобразовываться в число. По факту переменная получит числовой код этого символа в таблице ASCII.",
			"Переменной letter, наоборот, присваивается число, хотя эта переменная представляет тип char. Это число будет преобразовываться в символ, и в итоге переменная letter будет хранить символ, чей код в таблице ASCII равен 103, то есть символ 'g'.",
			"Результатом этой программы будет следующий консольный вывод: \n<b>g in ASCII is 103</b> \nКак выполняются преобразования:",
			"Переменной типа <b>bool</b> присваивается значение другого типа. В этом случае переменная получает <b>false</b>, если значение равно 0. Во всех остальных случаях переменная получает <b>true</b>. \nbool a = 1; //true \nbool b = 0 //false \nbool c='g'; //true \nbool d = 3.4 //true",
			"Числовой или символьной переменной присваивается значение типа <b>bool</b>. В этом случае переменная получает 1, если значений равно <b>true</b>, либо получает 0, если присваиваемое значение равно <b>false</b>. \nint c = true; //1 \ndouble d = false; //0",
			"Целочисленной переменной присваивается дробное число. В этом случае дробная часть после запятой отбрасывается \nint a = 3.4 //3 \nint b = 3.6 //3",
			"Переменной, которая представляет тип с плавающей точкой, присваивается целое число. В этом случае если целое число содержит больше битов, чем может вместить тип переменной, то часть информации усекается. \nfloat a = 35005; //35005 \ndouble b = 3500500000033; //3.5005e+012",
			"Переменной беззнакового типа (unsigned) присваивается значение не из его диапазона. В этом случае результатом будет остаток от деления по модулю. Например, тип unsigned char может хранить значения от 0 до 255. Если присвоить ему значение вне этого диапазона, то компилятор присвоит ему остаток от деления по модулю 256 (так как тип unsigned char может хранить 256 значений). Так, при присвоении значения -1 переменная типа unsigned char получит 256 - |-1/256| = 255",
			"1. unsigned char a = -5; //251 \nunsigned short b = -3500; //62036 () \nunsigned int c = -5000000000; //4244967296 \nПеременной знакового типа (signed) присваивается значение не из его диапазона. В этом случае результат не определен. Программа может работать нормально, выдавая адекватный результат, а может работать некорректно."
		],
		
		"page_2":
		[
			"<b>Опасные и безопасные преобразования</b>",
			"Те преобразования, при которых не происходит потеря информации, являются безопасными. Как правило, это преобразования от типа с меньшей разрядностью к типу с большей разрядностью. В частности, это следующие цепочки преобразований:",
			"<b>bool -> char -> short -> int -> double -> long double</b> \n<b>bool -> char -> short -> int -> long -> long long</b> \n<b>unsigned char -> unsigned short -> unsigned int -> unsigned long</b> \n<b>float -> double -> long double</b>",
			"Примеры безопасных преобразований:\nshort a = 'g'; //преобразование из char в short \nint b = 10; \ndouble c = b; //преобразование из int в double \nfloat d = 3.4 \ndouble e = d //преобразование из float в double \ndouble f =35; //преобразование из int в double",
			"Но также есть опасные преобразования. При подобных преобразованиях мы потенциально можем потерять точность данных. Как правило, это преобразования от типа с большей разрядностью к типу с меньшей разрядностью. \nchar letter = 295; \nstd::cout&lt;&lt;letter;",
			"В данном случае переменной letter присваивается значение, которое выходит за пределы диапазона допустимых значений для типа char, то есть больше 255.",
			"И в подобных примерах многое зависит от компилятора. В ряде случаев компиляторы при компиляции выдают предупреждение, тем не менее программа может быть успешно скомпилирована. В других случаях компиляторы не выдают никакого предупреждения. Собственно в этом и заключается опасность, что программа успешно компилируется, но тем не менее существует риск потери точности данных."
			"И, как правило, в подобных случаях при компиляции присваиваемое значение усекается до допустимого. Например, в примере выше число 295 будет сокращено до 39. То есть следующие переменные будут содержать одно и то же значение: \nchar letter1 = 295; \nchar letter2 = 39;"
		]
	},
	
	"constants": 
	{
		"name": "Константы",
		"page_1":
		[
			"Отличительной особенностью переменных является то, что мы можем многократно в течение работы программы изменять их значение: \n<code>int x = 7; \nx = 9; \nx = 5;</code> \nНо кроме переменных в языке программирования C++ можно определять константы. Их значение устанавливается один раз и впоследствии мы его не можем изменить. Константа определяется практически также, как и переменная за тем исключением, что в начале определения константы идет ключевое слово const. Например:
			"<code>const int x = 22; \nstd::coutt&lt;&lt;x;</code> \nЕсли же мы захотим после определения константы присвоить ей некоторое значение, то компилятор не сможет скомпилировать программу и выведет ошибку: \n<code>const int x = 22; \nx = 78;</code>",
			"То есть такой код не будет работать. И так как нельзя изменить значения константы, то ее всегда необходимо инициализировать, если мы хотим, чтобы она имела некоторое значение. \nЕсли константа не будет инициализирована, то компилятор также выведет ошибку и не сможет скомпилировать программу, как в следующем случае: \n<code>const int x;</code>",
			"В качестве значения константам можно передавать как обычные литералы, так и динамически вычысляемые значения, например, значения переменных или других констант: \n<code>int a = 10; \nconst int b = 7; \nconst int d = b; \nconst int x = a</code>",
			"Обычно в качестве констант определяются такие значения, которые должны оставаться постоянными в течение работы всей программы и не могут быть изменены. Например, если программы выполняет математические операции с использованием числа PI, то было бы оптимально определить данные значение как константу, так как оно все равно в принципе неизменно: \n<code>const float  pi = 3.14</code>"
		]
	},
	
	"console_io": 
	{
		"name": "Ввод/вывод в консоли",
		"page_1":
		[
			"По умолчанию язык C++ не содержит встроенных средств для ввода с консоли и вывода на консоль, эти средства предоставляются библиотекой iostream. В ней определены два типа: <b>istream</b> и <b>ostream</b>. istream представляет поток ввода, а ostream - поток вывода.",
			"Вобще сам темин 'поток' в данном случае представляет последовательность символов, которая записывается на устройство ввода-вывода или считывается с него. И в данном случае под устройством ввода-вывода рассматривается консоль. \nДля записи или вывода символов на консоль применяется объект <b>cout</b>, который представляет тип ostream. А для чтения с консоли используется объект <b>cin</b>. \nДля использования этих объектов в начало исходного файла необходимо подключить библиотеку iostream:
			"<code>#include &lt;iostream&gt;</code>",
			"<b>Вывод на консоль</b> \nДля вывода на консоль применяется оператор <b>&lt;&lt;</b>. Этот оператор получает два операнда. Левый операнд представляет объект типа ostream, в данном случае объект cout. А правый операнд - значение, которое надо вывести на консоль.",
			"Так как оператор &lt;&lt; возвращает левый операнд - cout, то с помощью цепочки операторов мы можем передать на консоль несколько значений. Например, определим простейшую программу вывода на консоль:",
			"<code>#include &lt;iostream&gt; \nint main() \n{ \nint age = 33; \ndouble weight = 81.23; \nstd::cout &lt;&lt; 'Name:' &lt;&lt; 'Tom' &lt;&lt; '\n'; std::cout << 'Weight:' &lt;&lt; weight &lt;&lt; std::endl; \nreturn 0; \n}</code>",
			"Консольный вывод программы: \n<b>Name: Tom \nAge: 33 \nWeight: 81.23</b> \nОператору &lt;&lt; передаются различные значения - строки, значения переменных, которые выводятся на консоль.",
			"Строки могут содержать управляющие последовательности, которые интерпретируются определенным образом. Например, последовательность '\n' интерпретируется как перевод на новую строку. Из других управляющих последовательностей также нередко употребляется '\t', которая интерпретируется как табуляция.",
			"Также цепочку операторов &lt;&lt можно завершать значением <b>std::endl</b>, которое вызывает перевод на новую строку и сброс буфера. При выводе в поток данные вначале помещаются в буфер. И сброс буфера гарантирует, что все переданные для вывода на консоль данные немедлено будут выведены на консоль."
		],
		
		"page_2":
		[
			"<b>Ввод с консоли</b>",
			"Для считывания с консоли данных применяется оператор ввода <b>&lt;&lt:</b>, который принимает два операнда. Левый операнд представляет объект типа istream (в данном случае объект cin), с которого производится считывание, а правый операнд - объект, в который считываются данные. \nНапример, считаем данные с консоли:",
			"<code>#include &lt;iostream&gt; \nint main() \n{ \nint age; \ndouble weight; \nstd::cout &lt;&lt; 'Input age:'; \nstd::cin &lt;&lt; age; \nstd::cout &lt;&lt; 'Input weight:'; \nstd::cin &lt;&lt; weight; \nstd::cout &lt;&lt; 'Your age:' &lt;&lt; age &lt;&lt; '\t your weight:' &lt;&lt; weight &lt;&lt; std::endl; \nreturn 0; \n}</code>",
			"Здесь после приглашений к вводу программа ожидает ввода значений для переменных age и weight. \nПример работы программы: \n<b>Input age: 32 \nInput weight: 67.45 \nYour age: 32	your weight: 67.45</b></code>",
			"Стоит отметить, что так оператор ввода в первом случае будет добавлять данные в целочисленную переменную age, то он ожидает ввода числа. В случае с переменной weight оператор ввода ожидает дробное число, причем разделителем целой и дробной части должна быть точка. Поэтому мы не можем ввести любые значения, например, строки. В этом случае программа может выдать некорректный результат.",
			"Оператор ввода &lt;&lt; возвращает левый операнд - объект cin, поэтому мы можем по цепочке считывать данные в различные переменные: \n<code>#include &lt;iostream&gt; \nint main() \n{ \nint age; \ndouble weight; \nstd::cout &lt;&lt; 'Input age:'; \nstd::cin &lt;&lt; age &lt;&lt; weight; \nstd::cout &lt;&lt; 'Your age:' &Lt;&lt; age &lt;&lt; '\t your weight:' &Lt;&lt; weight &lt;&lt; std::endl; \nreturn 0; \n}</code>",
			"Пример работы программы: \n<b>Input age: 32 67.45 \nYour age: 32	your weight: 67.45</b> \nПосле ввода одного из значений надо будет ввести пробел и затем вводить следующее значение."
		]	
			
	},
	
	"namespaces": 
	{
		"name": "Пространства имён",
		"page_1":
		[
			"При чтении и записи в предыдущих темах использовались объекты std::cout и std::cin соответственно. Причем они использовались с префиксом <b>std::</b>. Этот префикс указывает, что объекты cout, cin, endl определены в пространствен имен <b>std</b>. А само двойное двоеточие :: представляет оператор области видимости (scope operator), который позволяет указать, в каком пространсте имен определен объект. И без префикса эти объекты по умолчанию мы использовать не можем.",
			"Однако подобная запись может показаться несколько громоздкой. И в этом случае можно использовать оператор <b>using</b>, который позволяет ввести в программу объекты из различных пространств имен. \nИспользование оператора using имеет следующй формат: \n<code>using namespace::object</code>",
			"Например, пусть у нас есть следующая программа: \n<code>#include &lt;iostream&gt; \nint main() \n{ \nint age; \nstd::cout &lt;&lt; 'Input age:'; \nstd::cin &lt;&lt; age; \nstd::cout &lt;&lt; 'Your age:' &lt;&lt; age &lt;&lt; std::endl; \nreturn 0; \n}</code> \nЗдесь используются сразу три объекта из програнства имен std: cout, cin и endl. Перепишем программу с использованием using:",
			"<code>#include &lt;iostream&gt; \nusing std::cin; \nusing std::cout; \nusing std::endl; \nint main() \n{ \nint age; \ncout &lt;&lt; 'Input age:'; \ncin &lt;&lt; age; \ncout &lt;&lt; 'Your age:' &lt;&lt; age &lt;&lt; endl; \nreturn 0; \n}</code>",
			"Для каждого объекта из пространства std определяется свое выражение using. При этом программа будет работать также как и раньше."
	},
	"bit_operations": 
	{
		"name": "Побитовые операции"
	},
	"logical_operations": 
	{
		"name": "Логические операции"
	},
	"conditional_constructions": 
	{
		"name": "Условные конструкции"
	},
	"loops": 
	{
		"name": "Циклы"
	},
	"links": 
	{
		"name": "Ссылки"
	},
	"arrays": 
	{
		"name": "Массивы"
	},
	"strings": 
	{
		"name": "Строки"
	}
}

